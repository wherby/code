# 非连续区域处理
在非连续区域的时候，如果遍历各个可能的区域就会增加复杂度，使用DP或者区域扩散的单调性使得查询的时候就只处理当前的区域就可以降低复杂度


## 上下限查询
查询在[a,b]直接的区域，如果预处理的时候，可能 a<=c < d <= b 的 [c,d] 需要扩展到 a,b 可以直接查询到状态 
[值域查询预处理](../../codeforce/技巧/值域预处理/查询值域预处理.py)



## 树上找到两个路径无交叉的最小值的最大值
这里对的两个路径可能不连接(相交)，用DP预处理的方式，把最大值的子树连接在一起


## 状态包含技巧
[状态向包含的状态扩展](状态包含技巧/最高位计算.py)


## SOSDP 也解决了可能的状态对应值
因为互补的时候，多余的重叠值就是收益，所以一个状态可以对应多个具有重复值的状态，利用SOSDP使得重复的状态往边界合并
得到最佳的互补状态值
[SOSDP使得状态合并并记录最佳值](SOSDP解决多状态搜索问题/SOSDP解决状态包含问题.py)



## [sellingWood](多选择反向dp/q2312.py)
sell wood 的时候，为了让状态连续，则有 此状态缩放，2维缩放
···
        for i in range(1,m+1):
            for j in range(1,n+1):
                dp[i][j]= max(dp[i][j], dp[i-1][j])
                dp[i][j]= max(dp[i][j], dp[i][j-1])
···
