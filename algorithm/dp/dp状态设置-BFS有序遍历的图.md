#

https://codeforces.com/problemset/problem/1906/J

https://github.com/Yawn-Sean/Daily_CF_Problems/blob/main/daily_problems/2025/03/0328/solution/cf1906j.md

**提示 1：** 遍历到第 $i$ 个点时的可能状态如何？

**提示 2：** 上述状态转移取决于 $i$ 连出了多少个新点。

考虑遍历到第 $i$ 个元素时，真正重要的信息。

真正重要的就是此时队列里有多少个元素，也就是队列中出现最靠后的元素到底是什么，不妨设是 $j$ ，我们考虑 $dp[i][j]$ 。

$dp[i][j]$ 是由哪些元素转移过来的呢？

在遍历到第 $i$ 个元素前，一定遍历的是第 $i-1$ 个元素，因此一定是从 $dp[i-1][j']$ 转移过来的。

而为了队列能从 $j'$ 到 $j$ ，我们需要 $i-1$ 和 $j'+1,\dots, j$ 都连边。而同时，为了保证 $j'+1,\dots, j$ 之间是按照对应顺序进行遍历的，因此需要满足原序列 $j'+1,\dots, j$ 是递增的。

于是对应的 $j'$ 是从某个能满足上述条件的 $j_0$ 到 $j$ 的一个整数，即 $j'\isin[j_0,j]$ 。

状态转移如何呢？我们考虑遍历到 $i$ 时， $i-1$ 之前的点连的边都确定了，则从 $dp[i-1][j]$ 转移到 $dp[i][j']$ 时，只需考虑 $i-1$ 这个点连出的边有哪些。发现 $i-1$ 可向 $i,\dots,j$ 任意连边，因此： $dp[i][j]=\sum_{j'\isin[j_0,j]}2^{j-(i-1)}dp[i-1][j']$ 。右侧是一个区间和，因此可以维护前缀和后快速得到。

整理一下，考虑这步状态转移时，实际上考虑的是 $i-1$ 连了哪些边——一些不会被 BFS 走到的边 $i-1\to x\isin[i,j']$ 和会被走到的边 $j'+1,\dots,j$ 。

最后返回 $dp[n-1][n-1]$ 即可。由于这里只涉及 $i-1,i$ 的转移，因此可以滚动数组维护。

时间复杂度为 $\mathcal{O}(n^2)$ 。

``` python
def main():
    n = II()
    nums = LII()

    mod = 998244353

    prev = list(range(n))
    for i in range(1, n):
        if nums[i] > nums[i - 1]:
            prev[i] = prev[i - 1]

    dp = [0] * n
    acc = [0] * (n + 1)
    dp[0] = 1

    for i in range(1, n):
        pw = 1
        for j in range(i - 1, n):
            acc[j + 1] = (pw * dp[j] + acc[j]) % mod
            pw = pw * 2 % mod
        
        for j in range(i, n):
            dp[j] = (acc[j + 1] - acc[fmax(prev[j] - 1, 0)]) % mod
        
        for j in range(n + 1):
            acc[j] = 0

    print(dp[n - 1])
```

初始理解问题
首先，我需要明确题目在讨论什么。从提示中可以看出，这是一个关于图遍历的问题，具体来说，是关于广度优先搜索（BFS）遍历的顺序和图的构建。问题的核心在于：给定一个特定的BFS遍历顺序，计算有多少种不同的有向图可以产生这样的遍历顺序。

BFS遍历的基本概念
在标准的BFS中，我们从起点开始，依次访问其邻居，然后访问邻居的邻居，以此类推。在这个过程中，节点的访问顺序是固定的，即按照“层级”顺序访问。然而，图的边可以有不同的连接方式，只要它们不违反BFS的遍历顺序。

问题建模
假设我们有一个序列，表示BFS遍历的顺序：0, 1, 2, ..., n-1。我们需要计算有多少种有向图可以产生这个特定的BFS顺序。关键在于：

遍历顺序的保持：BFS的顺序必须严格按照0, 1, 2, ..., n-1的顺序。

边的限制：边的添加不能破坏这个顺序。具体来说，如果i在j之前被访问，那么不能有从j指向i的边（否则可能会改变遍历顺序）。

动态规划的状态定义
提示中提到了动态规划（DP）的状态定义：dp[i][j]。这里的i和j代表什么？

i：当前遍历到的节点编号。即我们已经处理了前i个节点（0到i-1）。

j：队列中最靠后的节点。即在BFS队列中，最后一个被加入的节点是j。

因此，dp[i][j]表示：在处理到第i个节点时，队列中最靠后的节点是j的情况下，可以构建的图的数目。

状态转移
接下来，我们需要考虑如何从dp[i-1][...]转移到dp[i][j]。

从i-1到i：当我们从处理i-1转移到处理i时，我们需要考虑i-1节点的出边。

队列的变化：在BFS中，处理i-1时，会将其邻居加入队列。这些邻居必须是在i-1之后未被访问的节点。

新加入的节点：i-1可以连接到i, i+1, ..., j中的某些节点。这些连接会影响队列的最靠后节点j。

具体来说：

假设在处理i-1之前，队列中最靠后的节点是j'。

i-1可以连接到i到j'中的某些节点。这些连接会将新的节点加入队列。

为了保证队列的最靠后节点变为j，i-1必须连接到j' + 1到j中的某些节点，并且j' + 1到j在原序列中是递增的（即这些节点是按顺序加入队列的）。

转移的数学表达
根据提示，状态转移可以表示为：

dp[i][j] = sum_{j' ∈ [j0, j]} 2^{j - (i - 1)} * dp[i - 1][j']

解释：

j0是某个起始点，确保j' + 1到j是递增的。

2^{j - (i - 1)}：i-1可以自由地连接到i到j'中的任何节点（因为这些连接不会影响队列的最靠后节点），所以有2^{j' - (i - 1)}种选择。但这里可能需要更精确的解释。

更准确的理解：

i-1必须连接到j' + 1到j中的所有节点（以确保它们被加入队列）。

i-1可以自由选择是否连接到i到j'中的节点（因为这些连接不会改变队列的最靠后节点）。

因此，对于i-1到i到j'的边，有2^{j' - i + 1}种选择。

但提示中的表达式是2^{j - (i - 1)}，可能需要结合j'的范围来理解。

前缀和优化
由于转移涉及到一个区间的和，可以使用前缀和来优化计算，避免重复计算。

边界条件和初始状态
初始状态：dp[0][0] = 1，表示处理第0个节点时，队列中最靠后的节点是0（即只有起点）。

最终答案：dp[n-1][n-1]，表示处理完所有节点后，队列中最靠后的节点是n-1（即所有节点都被处理）。

滚动数组优化
由于dp[i][j]只依赖于dp[i-1][...]，可以使用滚动数组来节省空间，即只保留前一行的DP值。

示例验证
为了更好地理解，可以用一个小例子来验证：

假设n=3，序列为0,1,2。

初始：dp[0][0] = 1。

计算dp[1][1]：

i=1, j=1。

j'的范围：需要j' + 1到1是递增的，即j'可以是0。

dp[1][1] = 2^{1 - 0} * dp[0][0] = 2 * 1 = 2。

i-1=0可以连接到1（必须连接），也可以选择是否连接到1之前的节点（没有，所以只有连接到1的选择）。

可能的两张图：

0->1。

0->1, 0->2（但此时j应该是2？可能需要更精确的计数）。

可能需要更精确的转移定义。

重新思考转移
更准确的转移：

dp[i][j]：处理到i时，队列中最靠后的是j。

从i-1到i：

之前队列最靠后的是j'。

i-1必须连接到j' + 1到j中的所有节点（以确保它们被加入队列）。

i-1可以自由连接到i到j'中的节点（不影响队列最靠后）。

因此，dp[i][j] = sum_{j'} dp[i-1][j'] * 2^{j' - i + 1}，其中j'满足j' + 1到j递增。

对于j' = j：

i-1不需要连接到任何新节点（因为j' + 1 > j），所以i-1可以自由连接到i到j。

dp[i][j] += dp[i-1][j] * 2^{j - i + 1}。

对于j' = j - 1：

i-1必须连接到j。

可以自由连接到i到j - 1。

dp[i][j] += dp[i-1][j - 1] * 2^{j - 1 - i + 1} = dp[i-1][j - 1] * 2^{j - i}.

等等。

简化转移
提示中给出的转移：

dp[i][j] = sum_{j' ∈ [j0, j]} 2^{j - (i - 1)} * dp[i - 1][j'].

这里的2^{j - (i - 1)}可能是i-1可以自由连接到i到j中的某些节点。

可能需要理解为：

dp[i][j] = sum_{j'} dp[i-1][j'] * 2^{j' - i + 1}，其中j'满足j' + 1到j递增。

但j'的范围需要明确。

可能的正确转移
更合理的可能是：

dp[i][j] = sum_{k = i-1}^{j} dp[i-1][k] * 2^{k - i + 1}.

因为：

k是之前的队列最靠后。

i-1必须连接到k + 1到j（如果k < j）。

可以自由连接到i到k。

但这样可能复杂。

另一种理解：

dp[i][j]：i-1可以连接到i到j中的任意子集，但必须至少连接到j（如果j > i-1）。

但这样可能不准确。

参考提示的转移
按照提示：

dp[i][j] = sum_{j' ∈ [j0, j]} 2^{j - (i - 1)} * dp[i - 1][j'].

这里的j - (i - 1)可能是i-1可以自由连接到i到j中的节点数。

即：

i-1必须连接到j' + 1到j（如果j' < j）。

可以自由连接到i到j'。

自由连接的数目是j' - i + 1，所以2^{j' - i + 1}。

但提示中是2^{j - (i - 1)}，可能是笔误，应为2^{j' - (i - 1)}.

可能需要假设j0是i-1。

可能的正确表达式
假设j0 = i - 1：

dp[i][j] = sum_{j' = i - 1}^{j} dp[i - 1][j'] * 2^{j' - (i - 1)}.

因为：

j'从i - 1到j。

i - 1可以自由连接到i到j'，有2^{j' - i + 1}种选择。

必须连接到j' + 1到j（如果j' < j）。

但这样dp[i][j]会依赖于j'到j的连接。

可能需要dp[i][j]表示i-1连接到j，且之前j'满足j' + 1到j递增。

最终理解
综合提示，最可能的状态转移是：

dp[i][j] = sum_{j' = j0}^{j} dp[i - 1][j'] * 2^{j' - i + 1},

其中j0是满足j' + 1到j递增的最小j'。

然后2^{j' - i + 1}是i - 1可以自由连接到i到j'的边的数目。

示例验证
n=3：

dp[0][0] = 1.

dp[1][1]:

j' from 0 to 1.

j' = 0: dp[0][0] * 2^{0 - 1 + 1} = 1 * 1 = 1.

j' = 1: dp[0][1]不存在（因为j'不能大于i-1=0）。

So dp[1][1] = 1.

dp[1][2]:

j' from 0 to 2.

j' = 0: dp[0][0] * 2^{0 - 1 + 1} = 1 * 1 = 1.

j' = 1: dp[0][1]不存在.

j' = 2: dp[0][2]不存在.

So dp[1][2] = 1.

dp[2][2]:

i=2, j=2.

j' from 1 to 2.

j' = 1: dp[1][1] * 2^{1 - 2 + 1} = 1 * 1 = 1.

j' = 2: dp[1][2] * 2^{2 - 2 + 1} = 1 * 2 = 2.

So dp[2][2] = 1 + 2 = 3.

因此，dp[2][2] = 3，表示有3种有向图可以产生BFS顺序0,1,2。

可能的图：

0->1, 1->2.

0->1, 0->2, 1->2.

0->1, 0->2.

验证：

图1：BFS队列：0; 1; 2. 顺序0,1,2.

图2：BFS队列：0; 1,2; 顺序0,1,2.

图3：BFS队列：0; 1,2; 顺序0,1,2.

看起来都是合法的。

总结
通过动态规划，定义dp[i][j]为处理到第i个节点时队列中最靠后的节点是j的方案数。状态转移时，考虑i-1的出边选择，确保BFS顺序不变。使用前缀和优化可以高效计算。

最终答案
问题的解法是使用动态规划，定义dp[i][j]，并通过状态转移和前缀和优化来计算。最终答案为dp[n-1][n-1]。