
# DFSN 与欧拉序

欧拉序在实现的时候，出栈操作不会增加序列号，所以点对应的欧拉序是. u=>  [ls[u], rs[u]) 的前闭后开区间

DFSN  在实现的时候，在出栈操作有时会增加序列号， 所以对应的区间可以是双闭区间 u=> [ls[u],rs[u]]

在算法实现的时候，查询区间更新造成的影响，应该注意区分采用的哪个序列实现，注意区间
[在这里采用欧拉序，所以 fen.rsum(ls[u], rs[u] - 1) + nums[idx] 采用前闭后开的区间查询 ](../../codeforce/图论/平衡括号序列等价树,py)

DFSN(第二类欧拉序)
[第二类欧拉序路径求取，BFS,使用倍增找LCA，BIT记录路径和](DFSN/第二类欧拉序.py)
[第一类欧拉序路径求取,DFS,使用DFSN判定是否子节点，利用DFSN特性查询路径](DFSN/第一类欧拉序.py)
BIT 特性是让更改累积前缀和，使用前缀和


总结：两类欧拉序的“抵消”对比你现在发现了吗？其实你提到的两种欧拉序解法，本质上都在利用“抵消”，只是抵消的维度不同：
第一类（DFS 序 + 差分）：是在一维坐标轴上抵消。利用“修改区间”的终点来抵消掉对区间外（枝干）的影响。
第二类（括号序 $2N$）：是在时间流中抵消。利用节点第二次出现（离开时）来抵消掉第一次出现（进入时）的影响。



核心原因在于：**这两者“抵消”的物理含义完全不同。**

### 1. 第一类欧拉序：抵消的是“空间”

在第一类序中，BIT 维护的是**从根到当前点的路径快照**。

* **逻辑**：每个点只负责“投喂”自己的子树。
* **公式意义**： 就像是从根拉下来的一条光束。当你异或  和  时，你是把两条从根出发的光束重叠。重叠的部分（根到  的上方）自然就抵消了。
* **为什么简单**：因为它本质上是在做**“路径减法”**。

---

### 2. 第二类欧拉序：抵消的是“时间/次数”

在第二类序中，线段树维护的是**序列中节点的出现次数**。它的逻辑是：**“如果一个点在区间内出现了两次，它就不在路径上。”**

为什么它必须分情况？请看  在  序列中的表现：

#### 情况 A： 是  的祖先

在欧拉序列中，当你从  进入，一路走到  进入，这个区间  包含了：

* 路径上的所有点（它们都刚进去，只出现一次）。
* 路径旁边的完整枝干（它们进去了又出来了，出现两次，被抵消）。
* **结果**：区间异或和直接就是路径和。

#### 情况 B： 和  在不同分支

这时你从  离开（）出发，走向  进入（）。这个区间  包含了：

*  到  路径上除去  以外的所有点。
* **关键点**： 此时处于“已进入但未离开”的状态。但在欧拉序的时间轴上， 的进入动作发生在  **之前**。
* **结果**： 根本不在  这个区间里！所以它没被算进去，你必须手动把它异或回来。

---

### 3. 深度对比：为什么第二类序“显得”更笨？

| 特性 | 第一类 (你给的代码) | 第二类 (括号序) |
| --- | --- | --- |
| **维护对象** | **根到点的路径状态** | **节点出现的瞬间** |
| **计算逻辑** | 路径 A - 路径 B | 区间内的元素残留 |
| **公式统一性** | 极高（始终是路径相减） | 低（取决于  是否在扫描区间内） |
| **优势场景** | **动态路径和/异或** | **处理路径上的非可逆贡献（如种类数）** |

### 4. 总结：为什么要分情况？

第二类序分情况是因为：**在非祖先情况下， 是路径的“拐点”，但在时间轴上，它是包围整个扫描区间的“外壳”。**

* 第一类序通过 **“差分”** 这种数学手段，强行把  的贡献注入到了它的所有后代里，所以公式统一了。
* 第二类序通过 **“物理扫描”** 这种手段，只能看到区间内发生的事情，而  恰好在区间外面看着。

**简单来说：第一类序是“逻辑上的路径叠加”，而第二类序是“物理上的路径扫描”。**



[树上倍增两种实现](DFSN/树上倍增两种实现.md)

### 第二类欧拉序路径查询 分情况：
路径转化：若 LCA(u, v) = u，路径区间为 [in[u], in[v]]。
若 LCA(u, v) != u，路径区间为 [out[u], in[v]]，需额外异或 mask(LCA)。
```python
u, v = int(a), int(b)
if tin[u] > tin[v]: u, v = v, u
lca = get_lca(u, v)

if lca == u:
    res_mask = st.query(tin[u], tin[v])
else:
    res_mask = st.query(tout[u], tin[v]) ^ node_masks[lca]
```