# 
[计算树上路径上互质的个数](../../mathA/组合数学/计算互质的对数)

# DFSN 序计算
假设树是 edges = [[0,1],[0,2],[1,3],[1,4],[2,5]] 
DFS遍历序是 [0, 1, 3, 3, 4, 4, 1, 2, 5, 5, 2, 0] L:[0, 1, 7, 2, 4, 8] R:[11, 6, 10, 3, 5, 9]

[如果用莫队算法计算非线性答案，则在移动过程中不能保证所有的节点移动都是有意义的](../../mathA/组合数学/计算互质的对数/CoPrimeOnTree.WrongAns.py)

为什么DFSN 不能正确得到结果，上面的图从点1到点2 经过了点0，因为点0 是起点，出现在第一和最后，所以无论怎么设置[L,R]都不会找到点0，

``` python
    def modify(x,op):
        nonlocal ans,sz
        print("modify:",(x,op))
        if FOP[T[x]] ==1:
            FOP[T[x]] = -1
        else:
            FOP[T[x]] = 1 
            op = -op
        sz +=op 
    ....
        while cur_li > li:
            cur_li -=1
            modify(cur_li,1)
        while cur_ri < ri:
            cur_ri +=1
            modify(cur_ri,1)
        while cur_li < li:
            modify(cur_li,-1)
            cur_li +=1
        while cur_ri > ri:
            modify(cur_ri,-1)
            cur_ri -=1
```

# 欧拉序遍历
[使用欧拉序遍历](../../mathA/组合数学/计算互质的对数/CoPrimeOnTree.2.py)
用欧拉序遍历，每次移动不是直接增加节点，而是找到两个相邻的欧拉序，看子节点与x节点的关系，增加，删除，子或者父节点,
欧拉序遍历和Deal函数的实质是维护了【L,R】在欧拉序遍历的时候形成区域的点，然后去掉重复边产生的点，就是路径

deal 函数 核心逻辑是这样的：
确定移动方向：if (v == Fa[u]) swap(u, v); 这一行非常重要。它确保了总是从子节点向父节点移动（或者反过来）。如果 v 是 u 的父节点，那么 u 和 v 的位置被交换，使得 u 始终是子节点，v 始终是父节点。这简化了后面的逻辑。
判断路径关系：if (L[x] >= L[v] && R[x] <= R[v]) 这部分是在检查节点 x 是否位于以 v 为根的子树中。
更新路径：
如果 x 位于 v 的子树内，这意味着当前路径的端点 x 的LCA（最近公共祖先）是 v。当指针从 u 移动到 v 时，路径的改变是 u 被移除，v 被添加。因此，它调用 Modify(u, ...)。
否则，LCA 位于 v 的子树之外。当指针移动时，路径的改变是 v 被添加或移除，u 保持不变。因此，它调用 Modify(v, ...)。
Flag[v] ^= 1; 这行代码标记了节点 v 的状态，表示它是否在当前路径上。
