

# 
值域视角处理线段树
https://www.bilibili.com/video/BV1D4SiB5Ee3/?spm_id_from=333.1387.homepage.video_card.click&vd_source=ca787d3785cbd6247961eba27850fa0c


# https://leetcode.cn/discuss/post/3845319/di-478-chang-zhou-sai-by-leetcode-owk3/
解法 2：ST 表 & 可持久化线段树
求中位数，其实就是求一个长度为 l 的区间里，第 ⌈ 
2
l
​
 ⌉ 小的元素是多少。求区间里的第 k 小数，是可持久化线段树的经典应用。

由于本题是力扣第一次出现可持久化线段树这一知识点，这里以求区间里的第 k 小数为例，进行简要介绍。

可持久化线段树简介
可持久化线段树是什么意思？它可以做什么？

可持久化数据结构，是一种可以“回顾历史”的数据结构。这种数据结构允许使用者在执行了若干次操作后，仍然可以查看某次操作之前数据结构的样子。

举个例子，假如我们用一棵值域线段树维护一个序列里所有的元素。如果我们从左到右依次将元素加入线段树中，那么第 i 次操作之后，线段树里将包含序列的前 i 个元素。普通的线段树只能维护当前的形态，但如果我已经加入了 7 个元素，突然想看看只包含前 3 个元素的线段树是什么样子，可持久化线段树就可以实现这个功能。

为什么要查看某次操作之前的数据结构？这有什么用？

我们以求下标区间 [l,r] 里的第 k 小数为例。如果区间里的第 k 小数是 x，那么换句话说，x 就是满足“区间里至少有 k 个数小于等于 x”的最小元素。因此，一种做法是二分答案 x，然后检查区间里是否至少有 k 个元素小于等于它。

对于一棵值域线段树，线段树上的值域区间 [d,u] 记录的是当前序列中，满足 d≤y≤u 的元素 y 有几个。那我们是不是直接把值域区间 [1,x] 加起来，就得到了有几个元素小于等于 x 呢？

然而，如果我们已经往线段树里加入了 r 个元素，那么当前序列指的是下标区间为 [1,r] 的前缀，并不是我们想要的下标区间 [l,r]。

但是没关系，我们可以用下标区间 [1,r] 的结果，减去下标区间 [1,l−1] 的结果，就能得到下标区间 [l,r] 里，有几个元素小于等于 x。

可是普通线段树已经看不到下标区间 [1,l−1] 的结果了，这时候就需要可持久化线段树。此时，只要在可持久化线段树上，看看第 (l−1) 次操作之后线段树的形态，那时的线段树不就是下标区间 [1,l−1] 的结果吗？

这么神奇的数据结构，应该怎么实现？

接下来我们来实现可持久化线段树。最朴素的实现就是每次修改前，先把当前的线段树形态整个备份下来，然后再进行修改。然而，由于值域线段树上可能有 O(tlogV) 个节点，其中 t 是已经操作的次数，V 是值域。因此 q 次操作后，总复杂度将达到 O(q 
2
 logV)，比暴力还差点。

然而根据普通线段树的知识，值域线段树上的每次修改只会影响其中的 O(logV) 个节点。计算机科学中有一种非常重要的思想 copy-on-write（COW），广泛应用于操作系统、数据库等各个领域。它的意思是：只有当一个节点被修改时，我再单独备份那个节点，其它没有被修改到的节点就不要备份了。这样每次操作只会备份 O(logV) 个节点，总复杂度降为 O(qlogV)。