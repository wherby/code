
# 
https://codeforces.com/gym/106170/problem/K
https://github.com/Yawn-Sean/Daily_CF_Problems/blob/main/daily_problems/2025/11/1107/solution/cf106170k.md

你提到的上面那个 GPU 负载调整问题（寻找最小 $k$）与 Bellman-Ford 算法和可行性验证有关，是因为这个问题被巧妙地转化成了一个**差分约束系统（Difference Constraints System）**。

在差分约束系统中，**检测负权环**（或最长路径变体中的正权环）就等同于**验证约束集是否可行（一致）**。

---

## 1. 差分约束系统与图论

### 核心转化

任何形式为 $x_j - x_i \le w_{ij}$ 的线性不等式，都可以被视为图论中的一个约束。

* **变量 $x_i$**：对应图中的**节点**（即 `sol[i]` 数组）。
* **不等式 $x_j - x_i \le w_{ij}$**：对应图中的一条边 $i \to j$，权重为 $w_{ij}$。

### 可行性与最短路径

一个差分约束系统有解（即所有约束都是一致的，没有矛盾）的**充要条件**是：其对应的约束图中**不存在负权环**。

* 如果存在负权环，意味着沿着环累加约束会导致 $x_i - x_i \le \text{负数}$，这是一个矛盾（例如 $x_1 - x_2 \le 5$, $x_2 - x_3 \le -10$, $x_3 - x_1 \le 3$, 累加后 $0 \le -2$，不成立）。

### Bellman-Ford 的作用

Bellman-Ford 算法是解决最短路径问题和**检测负权环**的标准算法。因此，它被用来作为 $\text{Check}(k)$ 函数的核心：

1.  **构建图**：基于给定的 $k$（代码中的 `mid`），构建所有 GPU 负载约束和公司约束对应的图。
2.  **运行 Bellman-Ford/SPFA**：执行松弛操作。
3.  **验证可行性**：
    * 如果算法发现**负权环** $\implies$ 约束矛盾 $\implies$ $\text{Check}(k)$ 返回 `False`。
    * 如果算法**没有发现负权环** $\implies$ 约束一致 $\implies$ $\text{Check}(k)$ 返回 `True`。

## 2. 代码中的具体体现（最长路径变体）

你分析的代码采用了**最长路径**变体：它使用 $\text{fmax}(D[v], D[u] + w)$ 进行松弛。

* **不等式形式**：$x_j - x_i \ge w_{ij}$ 对应于最长路径问题。
* **图中的问题**：如果存在**正权环**，则最长路径趋向 $+\infty$，系统不一致。

代码中的 $n$ 次松弛操作和随后的**验证**逻辑，是为了等效地检测是否存在一个**正权环**：

1.  **$n$ 次松弛**：试图找到最长路径 `sol[i]`。
2.  **可行性验证**：检查 $n$ 次迭代后的 `sol` 数组是否仍然满足所有原始约束。如果**不满足**，说明 $n$ 步不足以让所有约束收敛到一个有效解，这最常见的原因就是**存在一个正权环**，导致距离估计值还在无限增大。

所以，Bellman-Ford（或其变体 SPFA）在代码中的作用就是 **图论工具**，用于高效地判断由 $k$ 值定义的**数千条线性不等式**是否能同时得到满足。