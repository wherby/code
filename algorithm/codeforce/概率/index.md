

# 小数的逆元
https://codeforces.com/gym/105394/problem/D
https://github.com/Yawn-Sean/Daily_CF_Problems/blob/main/daily_problems/2025/09/0922/solution/cf105394d.md

p = (1 - round(float(p) * 1000000) * pow(1000000, mod - 2, mod)) % mod

这行代码是一个非常巧妙且必要的处理，它将一个浮点数的概率值 p 转换成一个可以在模运算下进行计算的整数。

让我们一步步分解这行代码的逻辑：

1. 为什么要转换？
原始问题中，灯光的衰减因子是 (1-p)。但是，p 是一个小数，而我们的最终结果需要对 10^9 + 7 取模。在计算机中，浮点数的运算（例如 1 - 0.1）
与整数的模运算是完全不同的。直接将浮点数进行模运算会导致精度问题，甚至得到错误的结果。

为了解决这个问题，我们需要将 (1-p) 这个小数转换成一个与之等价的、可以在模世界中进行计算的整数。

2. 转换的步骤
假设 p 的值为 0.123456。

float(p): 将输入的字符串 p 转换为浮点数。

* 1000000: 将 p 乘以 10^6。由于 p 最多有6位小数，这个操作会将其变成一个整数。例如，0.123456 * 1000000 得到 123456。

round(...): 确保结果是精确的整数。

pow(1000000, mod - 2, mod): 这是一个关键步骤。根据费马小定理，a^(m-2) 在模 m 下等于 a 的乘法逆元。10^6 的乘法逆元就是 1/10^6。

所以，(round(float(p) * 1000000) * pow(1000000, mod - 2, mod)) 实际上是在计算 p 的整数形式除以 10^6，也就是还原 p。

3. 最终的计算
1 - (p 的整数形式)

p = (1 - round(float(p) * 1000000) * pow(1000000, mod - 2, mod)) % mod

这行代码就是在计算 (1 - p) % mod。它巧妙地将小数 p 转换为一个整数分数，然后利用模逆元进行除法，最终得到了 (1-p) 在模意义下的正确值。

总结来说，这行代码的作用就是将输入的小数概率 p 转换为模意义下的 1-p，从而让后续的所有计算都可以在整数的模运算世界中进行，避免了浮点数带来的精度问题。


p = (1 - round(float(p) * 1000000) * pow(1000000, mod - 2, mod)) % mod
<=> p=(1 -round(float(p) * 1000000) *(1/1000000 %mod) ) 
<=> p = (1-p)%mod   在mod空间的整数值 