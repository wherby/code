# https://codeforces.com/problemset/problem/126/A
# https://github.com/Yawn-Sean/Daily_CF_Problems/blob/main/daily_problems/2025/08/0812/solution/cf126a.md


# 解法思路分析
# 问题的目标是在满足水温不低于 t0 的前提下，让水温尽可能接近 t0。如果有多种选择，则优先选择总流量最大的方案。
# 代码的解法巧妙地利用了以下数学关系：
# 温度公式: 混合后的水温 t 由公式 t = (t1*y1 + t2*y2) / (y1+y2) 给出。
# 温度约束: t >= t0。
# 最优解:
# 为了让 t 尽可能接近 t0（同时 t >= t0），我们需要让 t 尽可能地小，即最接近 t0 的上限值。
# 这意味着对于每个 y1，我们应该选择一个最小的 y2，使得 t >= t0 仍然成立。
# 代码正是基于这个洞察来设计的。
# 1. 特殊情况处理
# if t0 == t1 and t0 == t2: print(x1, x2): 如果两种水温都等于目标温度，那么随便怎么混合都行。为了让总流量最大，直接把两个水龙头都开到最大。
# elif t0 == t1: print(x1, 0): 如果冷水温度恰好是目标温度，我们只需开冷水龙头，为了流量最大，开到 x1。
# elif t0 == t2: print(0, x2): 同理，如果热水温度恰好是目标温度，只需开热水龙头。

# 2. 通用情况（t1 < t0 < t2 或 t2 < t0 < t1）
# 通用情况才是算法的核心。代码简化了问题，避免了对 y1 和 y2 的双重循环。
# 核心公式: 代码中的 t = ((t0 - t1) * i + t2 - t0 - 1) // (t2 - t0) 这一行是关键。
# 它实际上在计算对于给定的 y1=i，满足 t >= t0 所需的最小 y2。
# 我们从 t >= t0 推导出的不等式是 y2 * (t2 - t0) >= y1 * (t0 - t1)。
# 为了求最小的整数 y2，我们需要对 y1 * (t0 - t1) / (t2 - t0) 进行向上取整。
# 向上取整的技巧是 (a + b - 1) // b，这正是代码中使用的公式。

# 单次循环: 代码只循环遍历了 y1（用 i 表示），从 1 到 x1。
# if t > x2: continue: 如果计算出的最小 y2 超过了热水龙头的最大流量，说明这个 y1 是无法满足温度要求的，直接跳过。
# if t * ans1 <= ans2 * i: ans1, ans2 = i, t: 这行代码是比较和更新最优解的核心。
# 它比较的是两个分数： t / i 和 ans2 / ans1。
# ans2 / ans1 代表了当前最优解的 y2/y1 比例。
# t / i 代表了当前循环中 (i, t) 这一对流量的 y2/y1 比例。
# 水温 t 与 y2/y1 的比例是单调递增的。为了让 t 尽可能接近 t0，我们需要让 y2/y1 这个比例尽可能小。
# t * ans1 <= ans2 * i 等价于 t / i <= ans2 / ans1。这行代码在寻找更小的 y2/y1 比例。
# 当找到更小的比例时，说明找到了一个水温更接近 t0 的方案，所以更新 ans1 和 ans2。
# 初始值: ans1 = 0, ans2 = x2。这实际上是设置了一个初始的比例 ans2/ans1 = x2/0，它是一个无限大的值。在循环中，任何一个有效的比例 t/i 都会比它小，从而使得第一次有效的 (i, t) 成为最优解。

# 3. 最终结果
# 循环结束后，ans1 和 ans2 中存储的就是最优的 y1 和 y2。代码直接打印 ans1 和 ans2。

# 总结
# 这段代码通过将问题从寻找最佳的 (y1, y2) 组合，转换成寻找最佳的 y2/y1 比例，有效地将一个双重循环问题简化为了一个单次循环问题，大大提高了效率。它利用了水温与流量比例的单调关系，通过向上取整找到每个 y1 对应的最佳 y2，并用分数比较的方式来找到整体最优解。

# 双向最大值求解， 混合温度最接近且必须大于t0 的时候 流量最大值
# 把二维枚举变成了一维枚举
# 在冷水枚举从 1到x1 的情况下， 看达到至少 t0需要多少 x2 ，设为t
# 如果 t>x2, 则在这个情况下无论怎么都不能达到温度。
# 如果 t/i <= ans2/ans1 因为 t/i表示最佳的温度配比，证明(i,t)这个温度一定是比预设温度更好，因为i是增大的，等于的时候，就会取到更大的流量值, 
# （t2 - t0 - 1）//(t2 - t0) 是向上取整的技巧，为什么能向上取整，因为如果是floor的话，混合的温度就达不到t0,所以只有ceil的时候，才能比t0大,这里有可能取了ceil 造成混合温度会高于t0, 但是后面比较 t/i <= ans2/ans1，前面的比例越小则越接近t0，用这个条件使得
#   一定会取得最接近t0的比例

import init_setting
from lib.cflibs import *
def main():
    t1, t2, x1, x2, t0 = MII()
    
    if t0 == t1 and t0 == t2:
        print(x1, x2)
    elif t0 == t1:
        print(x1, 0)
    elif t0 == t2:
        print(0, x2)
    else:
        ans1 = 0
        ans2 = x2
        
        for i in range(1, x1 + 1):
            t = ((t0 - t1) * i + t2 - t0 - 1) // (t2 - t0)
            if t > x2: continue
            if t * ans1 <= ans2 * i:
                ans1, ans2 = i, t
        
        print(ans1, ans2)