
##
https://codeforces.com/gym/106363/problem/E
https://github.com/Yawn-Sean/Daily_CF_Problems/blob/main/daily_problems/2026/02/0213/solution/cf106363e.md

这个题目要求包含i坐标的所有区间的MEX， 如果直接求坐标区间的MEX则很难
从而从值域求MEX =k 的所有分布情况下 对应的[L,R]区间，i坐标在区间的位置不同的不同的贡献，因为k是递增的，所对应的[L,R]区间会越来越大，

而中间的贡献其实是MEX>=K的分布，所以要求等于K的时候，我们需要用 [x>=k+1]  - [x >=k]   
就像分层蛋糕，虽然每层高度都是1，但是最高层的高度是K
比如，如果一个子数组的 MEX 是 3，那么它在 
k=1 时贡献一次，在 
k=2 时贡献一次，在 
k=3 时贡献一次，加起来正好是 3

然后根据对于i的次数，分成了两个差分序列，再在最后计算的时候累积求和

这是一个非常经典的贡献法（Contribution Method）问题。直接暴力计算每个子数组的 MEX 复杂度是 ，我们需要转换思路：**不计算每个子数组的 MEX，而是计算每个可能的 MEX 值  对哪些子数组产生了贡献。**

---

### 1. 核心思路：贡献法

对于每一个 index ，我们需要求：


由于  的充要条件是：**整数  全都出现在子数组  中。**
我们可以利用这个性质，通过计算  的子数组数量来累计答案：



所以，对于每个位置  的总和为：


---

### 2. 维护包含  的最小区间

定义  和  分别为数字  在原排列中出现的最小和最大下标。

* 当  时，。
* 当  增加时，，。

**关键结论：**
一个子数组  的 ，当且仅当  且 。

---

### 3. 计算对位置  的贡献

对于固定的 ，满足条件的子数组必须满足：

1. 包含所有 ：即  且 。
2. 包含当前位置 ：即 。

结合以上两点，对于每个 ，合法的  和  取值范围是：

* 
* 

满足条件的子数组数量为：


最终答案：


---

### 4. 算法优化：从  到 

如果对每个  都遍历一次 ，复杂度依然是 。但观察  的公式，我们可以发现随着  的增加， 递减， 递增。

我们可以把  拆解。注意到当  足够大，使得  或  时，公式的分界点会发生变化。
实际上，我们可以**反过来维护**：遍历 ，看这个  为哪些  贡献了多少。

对于固定的 ，它对位置  的贡献量是一个关于  的分段函数：

* 当  时：
* 当  时：
* 当  时：

这是一个**二阶差分**或者**线段树更新**可以解决的问题，但更简单的方法是使用**差分数组**维护：

1. 区间  是一个等差数列。
2. 区间  是一个常数。
3. 区间  是一个等差数列。

---

### 5. 实现逻辑 (Python 伪代码)

```python
def solve():
    n = int(input())
    a = list(map(int, input().split()))
    pos = [0] * n
    for i in range(n):
        pos[a[i]] = i + 1 # 1-based
    
    # 差分数组，用于处理二阶变化（等差数列）
    # 或者直接对每个 k 计算贡献区间
    diff = [0] * (n + 2)
    
    L, R = pos[0], pos[0]
    for k in range(1, n + 1):
        # 包含 0...k-1 的区间是 [L, R]
        # 我们要为所有满足 l <= L, r >= R 的 (l, r) 累计 1
        # 对于位置 i，贡献是 min(i, L) * (n - max(i, R) + 1)
        # 这里的 L, R 随着 k 增大而更新
        if k < n:
            L = min(L, pos[k])
            R = max(R, pos[k])

```

## K 是怎么去除的

你的直觉捕捉到了这个算法最核心的逻辑，但关于“减去上一层”的理解可以微调得更精确一点。
其实这里不需要显式地减去上一层。我们可以把这个过程想象成**“剥洋葱”或者“累计概率密度”**：
1. 为什么不需要“减去上一层”？
在贡献法中，我们利用了一个非常巧妙的恒等式：
对于任何一个非负整数 $X$（这里 $X$ 就是某个子数组的 MEX）：

$$X = \sum_{k=1}^{n} [X \ge k]$$
比如，如果一个子数组的 MEX 是 3，那么它在 $k=1$ 时贡献一次，在 $k=2$ 时贡献一次，在 $k=3$ 时贡献一次，加起来正好是 3。
这段代码的逻辑是：
循环到 $i=0$ 时（即 $k=1$），它找到了所有 $\text{MEX} \ge 1$ 的子数组，并给它们覆盖到的每个位置 $idx$ 都加了 1。
循环到 $i=1$ 时（即 $k=2$），它找到了所有 $\text{MEX} \ge 2$ 的子数组，并给它们覆盖到的每个位置 $idx$ 都加了 1。
...以此类推。
所以，如果一个子数组的 MEX 恰好是 $m$，它就会在循环的前 $m$ 次被统计到。通过这种自然叠加，每个子数组的 MEX 值就自动累加到了它包含的每个 index 上。
2. 这里的“区间增大”其实是“约束增强”
你提到的“L, R 区间增大”是指数字 0 到 $k$ 出现的物理跨度变大。
注意：随着 $k$ 增大，$[L, R]$ 范围是在扩大的。
但是，能够覆盖这个 $[L, R]$ 区间的子数组数量是在减少的（因为约束变严苛了：必须同时包含更多的指定数字）。
代码中 diff_0[l] += (n - r) * (l + 1)：
这里的 l 和 r 是当前 $0 \dots k$ 的边界。
随着 $k$ 增大，l 变小，r 变大。
结果就是 (n - r) 和 (l + 1) 都在变小。
这一层加到差分数组里的“增量”越来越小，这非常符合 MEX 的性质：MEX 越大的子数组越稀少。
3. “只计算一次”的真相
并不是每一层减去了上一层，而是每一层都在为“MEX 至少为 $k$”这个事实提供增量。
如果你想计算的是“MEX 恰好等于 $k$”的子数组数量，那确实需要用“$\text{count}(\ge k) - \text{count}(\ge k+1)$”。但因为我们要算的是 MEX 的总和，直接利用 $\sum P(\text{MEX} \ge k)$ 的叠加性质是最简洁的，完全避开了减法逻辑。
总结
你的理解中“每一层标记”是对的，但它不是在做差值，而是在做累加。
每一层 $k$：都在回答“有哪些子数组不仅包含之前的数字，还包含了新加入的数字 $k$？”
差分数组：像一个蓄水池，把这 $n$ 次循环抛进来的所有“贡献层”全部接住。
前缀和：最后统一结算，算出每个位置被多少层“水”覆盖过，那个高度就是 MEX 的总和。
这种“将总和转化为前缀概率/计数累加”的技巧在处理期望值、统计总和类题目时非常强大。你现在对这个 $O(n)$ 方案的信心是不是更足了？
