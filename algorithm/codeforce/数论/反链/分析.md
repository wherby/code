
# 
https://codeforces.com/gym/105775/problem/D
https://github.com/Yawn-Sean/Daily_CF_Problems/blob/main/daily_problems/2025/12/1219/solution/cf105775d.md

你的分析非常准确！这确实是标准的解题思路。让我来整理和补充这个分析：

## 1. 核心思路回顾

### 第一步：找到候选策略
选择所有**技能总分相同**的候选人，这样：
- 如果两个候选人总分相同但不同，那么必然存在某些技能A比B高，某些技能B比A高
- 所以它们**互相不可比较**（谁也不支配谁）

### 第二步：确定最优总分
我们需要找到使得**候选人数量最多**的那个总分。

设每个候选人的技能分数为 (x₁, x₂, ..., xₙ)，其中 1 ≤ xᵢ ≤ m。

定义总分：T = ∑xᵢ，范围从 n 到 nm。

我们要找：使得 N(T) 最大的 T 值，其中 N(T) = 满足 ∑xᵢ = T 且 1 ≤ xᵢ ≤ m 的向量数。

## 2. 为什么中间总分最优？

### 对称性原理
- N(T) 关于中点对称：N(T) = N(n(m+1) - T)
- 因为如果 (x₁, ..., xₙ) 满足 ∑xᵢ = T
- 那么 (m+1-x₁, ..., m+1-xₙ) 满足 ∑ = n(m+1) - T

### 单峰性
N(T) 是先增后减的单峰函数，最大值出现在：
\[
T_{\text{opt}} = \lfloor \frac{n(m+1)}{2} \rfloor \quad \text{或} \quad \lceil \frac{n(m+1)}{2} \rceil
\]

**注意**：我之前用标准化总分 S = ∑(xᵢ-1)，范围 0 到 n(m-1)，但你的 T = ∑xᵢ 更直观。

## 3. 容斥原理计数

### 无限制情况
如果只要求 xᵢ ≥ 1，那么方程 ∑xᵢ = T 的解数为：
\[
\binom{T-1}{n-1}
\]
（隔板法：在 T 个球之间的 T-1 个空隙中选 n-1 个放隔板）

### 加上上界 xᵢ ≤ m
我们需要排除那些有至少一个 xᵢ ≥ m+1 的情况。

设 A_i 表示事件 "xᵢ ≥ m+1"。

由容斥原理：
\[
N(T) = \sum_{k=0}^{n} (-1)^k \cdot (\text{至少有k个xᵢ ≥ m+1的方案数})
\]

### 计算"至少有k个xᵢ ≥ m+1"
1. 先选哪k个变量 ≥ m+1：\(\binom{n}{k}\) 种选法
2. 对这k个变量，令 yᵢ = xᵢ - m ≥ 1
3. 现在所有变量都 ≥ 1，总和要求：∑yᵢ(选中的) + ∑xᵢ(其他) = T
   即：∑所有变量 = T - k·m
4. 解数：\(\binom{(T - k·m) - 1}{n - 1}\)（如果 T - k·m ≥ n）

所以：
\[
N(T) = \sum_{k=0}^{\lfloor \frac{T-n}{m} \rfloor} (-1)^k \cdot \binom{n}{k} \cdot \binom{T - k·m - 1}{n - 1}
\]

## 4. 最终算法

### 计算最优 T
\[
T_{\text{opt}} = \left\lfloor \frac{n(m+1)}{2} \right\rfloor
\]
或等价地：
\[
T_{\text{opt}} = \left\lceil \frac{n(m+1)}{2} \right\rceil
\]
由于对称性，两者对应的 N(T) 相等或非常接近。

### 计算答案
\[
\text{答案} = N(T_{\text{opt}}) = \sum_{k=0}^{\lfloor \frac{T_{\text{opt}}-n}{m} \rfloor} (-1)^k \cdot \binom{n}{k} \cdot \binom{T_{\text{opt}} - k·m - 1}{n - 1} \mod 998244353
\]

### 特殊情况
1. 如果 T_{\text{opt}} < n：答案为 0（但实际不会发生，因为 T≥n）
2. 如果 m=1：所有人总分都是 n，只能选 1 个
3. 如果 n=1：只能选 1 个

## 5. 复杂度优化

### 计算二项式系数
需要预计算阶乘和逆元：
- 最大需要计算到：n 和 T_{\text{opt}} 的量级
- T_{\text{opt}} 最大约为 nm/2

### 时间复杂度
- 容斥求和：k 从 0 到 min(n, ⌊(T-n)/m⌋)
- 最坏情况：O(n/m) 项
- 总复杂度：O(n) 或 O(T/m)

## 6. 实现细节

```python
MOD = 998244353

def mod_pow(a, b, mod):
    res = 1
    while b:
        if b & 1:
            res = res * a % mod
        a = a * a % mod
        b >>= 1
    return res

def prepare_factorials(max_n):
    fact = [1] * (max_n + 1)
    inv_fact = [1] * (max_n + 1)
    
    for i in range(1, max_n + 1):
        fact[i] = fact[i-1] * i % MOD
    
    inv_fact[max_n] = mod_pow(fact[max_n], MOD-2, MOD)
    for i in range(max_n-1, -1, -1):
        inv_fact[i] = inv_fact[i+1] * (i+1) % MOD
    
    return fact, inv_fact

def comb(n, k, fact, inv_fact):
    if k < 0 or k > n:
        return 0
    return fact[n] * inv_fact[k] % MOD * inv_fact[n-k] % MOD

def solve(n, m):
    if n == 1 or m == 1:
        return 1 % MOD
    
    # 最优总分
    T_opt = n * (m + 1) // 2
    
    # 需要计算的最大阶乘
    max_val = max(n, T_opt)
    fact, inv_fact = prepare_factorials(max_val + n)  # 加n为了安全
    
    # 容斥求和
    result = 0
    max_k = min(n, (T_opt - n) // m)  # 注意：需要 T_opt - k*m ≥ n
    if max_k < 0:
        return 0  # 不可能的情况
    
    for k in range(max_k + 1):
        remaining = T_opt - k * m
        if remaining < n:  # 没有非负解
            break
        
        # 计算组合数：C(remaining - 1, n - 1)
        ways = comb(n, k, fact, inv_fact) * comb(remaining - 1, n - 1, fact, inv_fact) % MOD
        
        if k % 2 == 0:
            result = (result + ways) % MOD
        else:
            result = (result - ways) % MOD
    
    return (result % MOD + MOD) % MOD

# 测试
if __name__ == "__main__":
    print(solve(2, 2))  # 应该输出 2
    print(solve(2, 3))  # 应该输出 3
    print(solve(3, 2))  # 应该输出 3
```

## 7. 验证例子

### 例子1：n=2, m=2
- T_opt = 2*(2+1)//2 = 3
- N(3) = ?
  k=0: C(2,0)×C(2,1) = 1×2 = 2
  k=1: C(2,1)×C(3-2-1,1) = 2×C(0,1) = 0
结果：2 ✓

### 例子2：n=2, m=3
- T_opt = 2*(3+1)//2 = 4
- N(4) = ?
  k=0: C(2,0)×C(3,1) = 1×3 = 3
  k=1: C(2,1)×C(4-3-1,1) = 2×C(0,1) = 0
结果：3 ✓

## 8. 关键要点总结

1. **策略**：选择所有总分相同的候选人
2. **最优总分**：中间值 ⌊n(m+1)/2⌋
3. **计数方法**：容斥原理排除超出上界的情况
4. **公式**：
   \[
   \text{答案} = \sum_{k=0}^{\min(n, \lfloor\frac{T-n}{m}\rfloor)} (-1)^k \binom{n}{k} \binom{T - km - 1}{n-1}
   \]
   其中 \( T = \lfloor n(m+1)/2 \rfloor \)

这个解法的时间复杂度 O(n) 或 O(n/m)，空间复杂度 O(n)，可以处理较大的 n 和 m。