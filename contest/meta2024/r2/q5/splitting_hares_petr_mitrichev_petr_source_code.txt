/**
 * code generated by JHelper
 * More info: https://github.com/AlexeyDmitriev/JHelper
 * @author
 */

// Actual solution is at the bottom

#undef NDEBUG

#include <algorithm>
#include <array>
#include <bitset>
#include <cassert>
#include <climits>
#include <cstdint>
#include <cmath>
#include <complex>
#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <functional>
#include <iomanip>
#include <iostream>
#include <map>
#include <memory>
#include <numeric>
#include <queue>
#include <random>
#include <set>
#include <stack>
#include <string>
#include <unordered_set>
#include <unordered_map>
#include <vector>
// AtCoder library from https://github.com/atcoder/ac-library
// #include "../atcoder/all"

#define sz(v) ((int)(v).size())
#define all(v) (v).begin(),(v).end()

using namespace std;

using int64 = int64_t;
using ii = pair<int, int>;
int MAX_COORD = 1000;
int INF = (int) 1e5;

class DSplittingHares {
 public:
  void solveOne() {
    int n;
    cin >> n;
    vector<int> w(n);
    for (auto& x : w) cin >> x;
    vector<int> c(n);
    for (auto& x : c) {
      cin >> x;
      --x;
      assert(x >= 0 && x < n);
    }
    vector<int> num_unknown(n);
    vector<vector<int>> knowns(n);
    vector<vector<int>> unknown_positions(n);
    for (int i = 0; i < n; ++i) {
      if (w[i] < 0) {
        ++num_unknown[c[i]];
        unknown_positions[c[i]].push_back(i);
      } else knowns[c[i]].push_back(w[i]);
    }
    for (int i = 0; i < n; ++i) {
      if (num_unknown[i] + (int) knowns[i].size() >= 4) {
        cout << "No\n";
        return;
      }
    }
    vector<int> with_knowns;
    for (int i = 0; i < n; ++i) if (!knowns[i].empty()) {
      sort(all(knowns[i]));
      with_knowns.push_back(i);
    }
    sort(all(with_knowns), [&knowns](int a, int b) {
      return knowns[a][0] < knowns[b][0];
    });
    for (int i = 0; i + 1 < with_knowns.size(); ++i) {
      if (knowns[with_knowns[i]].back() >= knowns[with_knowns[i + 1]][0]) {
        cout << "No\n";
        return;
      }
    }
    vector<int> best(MAX_COORD + 1, -INF);
    vector<int> nbest(MAX_COORD + 1, -INF);
    vector<vector<int>> vias;
    best[0] = 0;
    for (int wi = 0; wi < with_knowns.size(); ++wi) {
      int which = with_knowns[wi];
      int amount = (int) knowns[which].size() + num_unknown[which];
      for (int step = 0; step < amount; ++step) {
        fill(all(nbest), -INF);
        vector<int> via(MAX_COORD + 1, -1);
        for (int old = 0; old <= MAX_COORD; ++old) {
          if (best[old] <= -INF) continue;
          int left = old + 1;
          int right = MAX_COORD;
          if (wi + 1 < with_knowns.size()) {
            right = knowns[with_knowns[wi + 1]][0] - 1;
          }
          for (int x : knowns[which]) {
            if (x > old) right = min(right, x);
          }
          for (int cur = left; cur <= right; ++cur) {
            int knowns_covered = 0;
            bool is_known = false;
            for (int x : knowns[which]) {
              if (x < cur) ++knowns_covered;
              if (x == cur) is_known = true;
            }
            int unknowns_covered = step - knowns_covered;
            assert(unknowns_covered >= 0);
            if (unknowns_covered + (is_known ? 0 : 1) > num_unknown[which]) continue;
            int us_score = INF;
            int best_same_as_us = INF;
            int best_diff_from_us = INF;
            int us_ctake = (step == 0 ? 0 : 1);
            int us_ptake = (step == 1 ? 0 : 1);
            for (int ptake = 0; ptake < 2; ++ptake) {
              if (old == 0 && ptake == 0) continue;
              int pscore = ptake == us_ptake ? 0 : best[old];
              for (int ctake = 0; ctake < 2; ++ctake) {
                if (old == 0 && ctake == 1) continue;
                if (ptake + ctake == 0) continue;
                int score = pscore;
                if (ctake == 1) score += cur - old;
                if (ptake == us_ptake && ctake == us_ctake) {
                  us_score = min(us_score, score);
                }
                if (ctake == us_ctake) {
                  best_same_as_us = min(best_same_as_us, score);
                } else {
                  best_diff_from_us = min(best_diff_from_us, score);
                }
              }
            }
            assert(us_score < INF);
            best_same_as_us -= us_score;
            best_diff_from_us -= us_score;
            if (best_same_as_us < 0) continue;
            if (best_diff_from_us > nbest[cur]) {
              nbest[cur] = best_diff_from_us;
              via[cur] = old;
            }
          }
        }
        best.swap(nbest);
        vias.push_back(via);
      }
      for (int old = 0; old <= MAX_COORD; ++old) {
        if (best[old] <= -INF) continue;
        assert(old >= knowns[which].back());
        if (num_unknown[which] == 0) {
          assert(old == knowns[which].back());
        }
      }
    }
    for (int old = 0; old <= MAX_COORD; ++old) {
      if (best[old] > -INF) {
        cout << "Yes\n";
        vector<int> used;
        int cur = old;
        while (cur > 0) {
          used.push_back(cur);
          cur = vias.back()[cur];
          vias.pop_back();
        }
        assert(vias.empty());
        reverse(all(used));
        int uptr = 0;
        for (int wi = 0; wi < with_knowns.size(); ++wi) {
          int which = with_knowns[wi];
          int amount = (int) knowns[which].size() + num_unknown[which];
          int vptr = 0;
          for (int step = 0; step < amount; ++step) {
            int at = used[uptr++];
            bool found = false;
            for (int x : knowns[which]) if (x == at) found = true;
            if (!found) {
              w[unknown_positions[which][vptr++]] = at;
            }
          }
          assert(vptr == num_unknown[which]);
        }
        int next = 2000;
        for (int i = 0; i < n; ++i) if (knowns[i].empty() && num_unknown[i] > 0) {
          for (int x : unknown_positions[i]) {
            w[x] = next++;
          }
          next += 50;
        }
        for (int i = 0; i < n; ++i) {
          assert(w[i] >= 0);
          if (i > 0) cout << " ";
          cout << w[i];
        }
        cout << "\n";
        return;
      }
    }
    cout << "No\n";
  }

  void solve() {
    int nt;
    cin >> nt;
    for (int it = 0; it < nt; ++it) {
      cout << "Case #" << (it + 1) << ": ";
      solveOne();
      cerr << "Case #" << (it + 1) << " done" << endl;
    }
  }
};

struct Workaround {
  int64_t tv_sec = 0;
  int64_t tv_nsec = 0;
} workaround;
#define st_mtimespec st_mtime + workaround

#include <dirent.h>
#include <stdexcept>
#include <regex>
#include <sys/stat.h>
#include <cstdint>

std::string getLastFileName(const std::string& regexString) {
	DIR* dir;
	dirent* entry;
	std::string result = "";
	int64_t resultModificationTime = 0;
	std::regex regex(regexString);
	if ((dir = opendir (".")) != NULL) {
		while ((entry = readdir (dir)) != NULL) {
			if (std::regex_match(entry->d_name, regex)) {
				struct stat buffer;
				stat(entry->d_name, &buffer);
				int64_t modificationTime = static_cast<int64_t>(buffer.st_mtimespec.tv_sec) * 1000000000 +
						static_cast<int64_t>(buffer.st_mtimespec.tv_nsec);

				if (modificationTime > resultModificationTime) {
					resultModificationTime = modificationTime;
					result = entry->d_name;
				}
			}
		}
		closedir (dir);
	} else {
		throw std::runtime_error("Couldn't open current directory");
	}
	if (result.empty()) {
		throw std::runtime_error("No file found");
	}	return result;
}

int main() {
    std::ios::sync_with_stdio(false);
    std::cin.tie(0);
    DSplittingHares solver;
    freopen(getLastFileName("splitting_hares_.*input[.]txt").c_str(), "r", stdin);
    freopen("splitting_hares_output.txt", "w", stdout);
    solver.solve();
    return 0;
}
