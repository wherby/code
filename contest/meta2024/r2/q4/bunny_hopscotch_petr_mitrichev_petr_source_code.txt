/**
 * code generated by JHelper
 * More info: https://github.com/AlexeyDmitriev/JHelper
 * @author
 */

// Actual solution is at the bottom

#undef NDEBUG

#include <algorithm>
#include <array>
#include <bitset>
#include <cassert>
#include <climits>
#include <cstdint>
#include <cmath>
#include <complex>
#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <functional>
#include <iomanip>
#include <iostream>
#include <map>
#include <memory>
#include <numeric>
#include <queue>
#include <random>
#include <set>
#include <stack>
#include <string>
#include <unordered_set>
#include <unordered_map>
#include <vector>
#include <thread>
// AtCoder library from https://github.com/atcoder/ac-library
// #include "../atcoder/segtree"

#define sz(v) ((int)(v).size())
#define all(v) (v).begin(),(v).end()

using namespace std;

using int64 = int64_t;
using ii = pair<int, int>;

class CBunnyHopscotch {
 public:
  struct Case {
    int height, width;
    int64 k;
    vector<vector<int>> b;
    vector<vector<int>> bflip;
    int result = -1;

    void read() {
      cin >> height >> width >> k;
      k = (k - 1) / 2;
      b = vector<vector<int>>(height, vector<int>(width));
      bflip = vector<vector<int>>(width, vector<int>(height));
      for (int r = 0; r < height; ++r) {
        for (int c = 0; c < width; ++c) {
          cin >> b[r][c];
          //b[r][c] = r * width + c + 1;
          --b[r][c];
          assert(b[r][c] >= 0 && b[r][c] < height * width);
          bflip[c][r] = b[r][c];
        }
      }
    }

    void solve() {
      vector<int64> counts(max(height, width) + 1);
      vector<int> am1(height * width);
      vector<int> am2(height * width);
      int tot1 = 0;
      int tot2 = 0;

      for (int r1 = 0; r1 < height; ++r1) {
        for (int r2 = r1 + 1; r2 < height; ++r2) {
          int delta = r2 - r1;
          auto &cres = counts[delta];
          auto &br1 = b[r1];
          auto &br2 = b[r2];
          for (int c = 0; c < width + delta + 1; ++c) {
            int d = c - delta - 1;
            int v;
            if (d >= 0) {
              v = br1[d];
              --am1[v];
              --tot1;
              v = br2[d];
              --am2[v];
              --tot2;
            }
            if (c < width) {
              v = br1[c];
              cres += tot2 - am2[v];
              ++am1[v];
              ++tot1;
              v = br2[c];
              cres += tot1 - am1[v];
              ++am2[v];
              ++tot2;
            }
          }
          assert(tot1 == 0);
          assert(tot2 == 0);
        }
      }

      for (int r1 = 0; r1 < width; ++r1) {
        for (int r2 = r1 + 1; r2 < width; ++r2) {
          int delta = r2 - r1;
          auto &cres = counts[delta];
          auto &br1 = bflip[r1];
          auto &br2 = bflip[r2];
          for (int c = 0; c < height + delta; ++c) {
            int d = c - delta;
            int v;
            if (d >= 0) {
              v = br1[d];
              --am1[v];
              --tot1;
              v = br2[d];
              --am2[v];
              --tot2;
            }
            if (c < height) {
              v = br1[c];
              cres += tot2 - am2[v];
              ++am1[v];
              ++tot1;
              v = br2[c];
              cres += tot1 - am1[v];
              ++am2[v];
              ++tot2;
            }
          }
          assert(tot1 == 0);
          assert(tot2 == 0);
        }
      }

      /*int64 psum = 0;
      for (int d = 1; d < counts.size(); ++d) {
        psum += counts[d];
        int64 expected = 0;
        for (int r = 0; r < height; ++r) {
          for (int c = 0; c < width; ++c) {
            int r1 = max(r - d, 0);
            int c1 = max(c - d, 0);
            expected += (r - r1 + 1) * (c - c1 + 1) - 1;
            r1 = min(r + d, height - 1);
            expected += (r1 - r) * (c - c1);
          }
        }
        cerr << d << " " << psum << " " << expected << endl;
        assert(psum == expected);
      }*/

      assert(counts.back() == 0);
      for (int res = 0; res < counts.size(); ++res) {
        if (k < counts[res]) {
          result = res;
          return;
        }
        k -= counts[res];
      }
      assert(false);
    }
  };

  void solve() {
    int nt;
    cin >> nt;
    vector<Case> cases(nt);
    for (int it = 0; it < nt; ++it) {
      cases[it].read();
    }
    int num_workers = 8;
    vector<thread> threads;
    threads.reserve(num_workers);
    for (int wid = 0; wid < num_workers; ++wid) {
      threads.emplace_back([&cases, wid, nt, num_workers]() {
        for (int it = wid; it < nt; it += num_workers) {
          cases[it].solve();
          cerr << "Case #" << (it + 1) << " done" << endl;
        }
      });
    }
    for (auto& th : threads) th.join();
    for (int it = 0; it < nt; ++it) {
      cout << "Case #" << (it + 1) << ": " << cases[it].result << "\n";
    }
  }
};

struct Workaround {
  int64_t tv_sec = 0;
  int64_t tv_nsec = 0;
} workaround;
#define st_mtimespec st_mtime + workaround

#include <dirent.h>
#include <stdexcept>
#include <regex>
#include <sys/stat.h>
#include <cstdint>

std::string getLastFileName(const std::string& regexString) {
	DIR* dir;
	dirent* entry;
	std::string result = "";
	int64_t resultModificationTime = 0;
	std::regex regex(regexString);
	if ((dir = opendir (".")) != NULL) {
		while ((entry = readdir (dir)) != NULL) {
			if (std::regex_match(entry->d_name, regex)) {
				struct stat buffer;
				stat(entry->d_name, &buffer);
				int64_t modificationTime = static_cast<int64_t>(buffer.st_mtimespec.tv_sec) * 1000000000 +
						static_cast<int64_t>(buffer.st_mtimespec.tv_nsec);

				if (modificationTime > resultModificationTime) {
					resultModificationTime = modificationTime;
					result = entry->d_name;
				}
			}
		}
		closedir (dir);
	} else {
		throw std::runtime_error("Couldn't open current directory");
	}
	if (result.empty()) {
		throw std::runtime_error("No file found");
	}	return result;
}

int main() {
    std::ios::sync_with_stdio(false);
    std::cin.tie(0);
    CBunnyHopscotch solver;
    freopen(getLastFileName("bunny_hopscotch_.*input[.]txt").c_str(), "r", stdin);
    freopen("bunny_hopscotch_output.txt", "w", stdout);
    solver.solve();
    return 0;
}
