from loguru import logger
from sympy.abc import x
from sympy import Sum
from scipy.special import digamma

# def efficient_eval(lo, hi, d, P)
# 	g = min((d-1) * P / 100, 1)
# 	return d / (g + (1-g) * rem / N)

def digamma_arith(lo, hi, add):
	# ans = 0
	# ans = 0
	return digamma(hi + 1 + add) - digamma(lo + add)
	# for i in range(lo, hi+1):
	# 	ans += 1 / (i + add)
	# return ans

def divide(l, r, dl, dr):
	if l + 1 == r:
		return 0

	def do_eval(d, rem):
		g = min((d-1) * P / 100, 1)
		if g == 1:
			return d
		return N * d / (1-g) / (N*g/(1-g) + rem)
		# return 1 / prob_win

	if dl == dr:
		d = dl
		g = min((d-1) * P / 100, 1)
		if g == 1: # OK
			# assert False
			return (r-l-1) * d
			# assert False
		return N * d / (1-g) * digamma_arith(l+1, r-1, N*g/(1-g))
	# 	return efficient_eval(l+1, r, dl, P)
	# 	# logger.debug(f"Opt ... {l=} {r=}")
	# 	# logger.debug(do_eval(dl, x))
	# 	# res = Sum(do_eval(dl, x), (x, l + 1, r - 1)).doit()
	# 	# logger.debug(f"{l=} {r=} {res=}")
	# 	return res

	m = (l + r) // 2

	d = 1
	max_prob_win = (float("inf"), 0)
	while True:
		max_prob_win = min(max_prob_win, (do_eval(d, m), d))
		if (d - 1) * P >= 100 or P == 0:
			break
		d += 1
	# print(l, r, max_prob_win, flush=True)
	return max_prob_win[0] + divide(l, m, dl, max_prob_win[1]) + divide(m, r, max_prob_win[1], dr)


def solve(N, P):
	return divide(0, N+1, 0, -1)

T = int(input())
for t in range(1, T+1):
	logger.debug(f"Doing {t=}")
	N, P = map(int, input().split())
	ans = solve(N, P)
	logger.debug(f"Done {t=}")
	print(f"Case #{t}: {ans:.15E}")