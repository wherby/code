// 2024.11.02 at 19:16:29 GMT
import java.io.*
import kotlin.system.measureTimeMillis
import java.util.TreeMap
import java.util.TreeSet
import kotlin.concurrent.thread
import kotlin.random.Random
import kotlin.random.nextInt

//All typealias that I use
typealias pii = Pair<Int,Int>
typealias pll = Pair<Long,Long> //stupid R/Gac two-sided recognitions
typealias ints = IntArray
typealias longs = LongArray
typealias bools = BooleanArray
// 1. Modded
fun Int.adjust():Int{ if(this >= p){ return this  - p }else if (this < 0){ return this + p };return this }
fun Int.snap():Int{ return if(this >= p){ this - p } else this }
infix fun Int.mm(b:Int):Int{ return ((this.toLong() * b) % p).toInt() }
infix fun Int.mp(b:Int):Int{ val ans = this + b;return if(ans >= p) ans - p else ans }
infix fun Int.ms(b:Int):Int{ val ans = this - b;return if(ans < 0) ans + p else ans }
fun Long.modded():Int = (this % p).toInt().adjust()
fun Int.inverse():Int = intPow(this,p-2)
fun Int.additiveInverse():Int = if(this == 0) 0 else p - this
infix fun Int.modDivide(b:Int):Int{ return this mm (b.inverse()) }
fun intPow(x:Int, e:Int):Int{
    var x = x; var e = e ; var ret = 1
    while(e > 0){
        if(e and 1 == 1) ret = ret mm x
        x = x mm x
        e = e shr 1
    }
    return ret
}
// 2. DP initial values
const val plarge = 1_000_000_727
const val nlarge = -plarge
const val phuge = 2_727_000_000_000_000_000L
const val nhuge = -phuge
//3. hard to write stuff
fun IntArray.put(i:Int,v:Int){ this[i] = (this[i] + v).adjust() }
val mint get() = mutableListOf<Int>()
val mong get() = mutableListOf<Long>()
val mchar get() = mutableListOf<Char>()
fun IntArray.minindex() = this.indexOf(this.minOrNull()!!)
fun IntArray.maxindex() = this.indexOf(this.maxOrNull()!!)
//4. more outputs
fun List<Char>.conca():String = this.joinToString("")
val CharArray.conca :String get() = this.concatToString()
val IntArray.conca :String get() = this.joinToString(" ")
@JvmName("concaInt")
fun List<Int>.conca():String = this.joinToString(" ")
val LongArray.conca:String get() = this.joinToString(" ")
@JvmName("concaLong")
fun List<Long>.conca():String = this.joinToString(" ")
@JvmName("concaString")
fun List<String>.conca():String = this.joinToString("")
//5. Simple calculations
val Boolean.chi:Int get() = if(this) 1 else 0 //characteristic function
val BooleanArray.chiarray:IntArray get() = IntArray(this.size){this[it].chi}
val Char.code :Int get() = this.toInt() -  'a'.toInt()
fun order(a:Int, b:Int):Pair<Int,Int> = Pair(minOf(a,b), maxOf(a,b))
val String.size get() = this.length
fun Int.has(i:Int):Boolean = (this and (1 shl i) != 0)
fun Long.has(i:Int):Boolean = (this and (1L shl i) != 0L)
fun dist(a: Int, b: Int): Int = if(a > b) a-b else b - a
fun dist(a: Long, b: Long): Long = if(a > b) a-b else b - a //chatgpt is right this is faster
//8 TIME
inline fun TIME(f:()->Unit){
    val t = measureTimeMillis{ f() }
    println("$t ms")
}
//9 rand
fun rand(x:Int) = Random.nextInt(x)
fun rand(x:IntRange) = Random.nextInt(x)
inline fun assert(x:Boolean,act:()->Any = {}){ if(!x) error(act())}
const val interactive = false
//11 Quick output
val YES:Unit get() = put("YES")
val NO:Unit get() = put("NO")
//12 Array put
inline fun chmin(array: IntArray, index: Int, newValue: Int) { if(newValue < array[index]) array[index] = newValue }
inline fun chmax(array: IntArray, index: Int, newValue: Int) { if(newValue > array[index]) array[index] = newValue }
inline fun chmin(array: LongArray, index: Int, newValue: Long) { if(newValue < array[index]) array[index] = newValue }
inline fun chmax(array: LongArray, index: Int, newValue: Long) { if(newValue > array[index]) array[index] = newValue }
@Target(AnnotationTarget.FUNCTION)  @Retention(AnnotationRetention.RUNTIME)  annotation class show
object Reader{
    private const val BS = 1 shl 16
    private const val NC = 0.toChar()
    private val buf = ByteArray(BS)
    private var bId = 0
    private var size = 0
    private var c = NC
    var fakein = StringBuilder()
    private var IN: BufferedInputStream = BufferedInputStream(System.`in`, BS)
    var OUT: PrintWriter = PrintWriter(System.out)
    private val char: Char
        get() {
            if(interactive){
                val c = System.`in`.read()
                return if(c == -1) NC else c.toChar()
            }
            while (bId == size) {
                size = IN.read(buf)
                if (size == -1) return NC
                bId = 0
            }
            return buf[bId++].toChar()
        } // Must terminate input process after reading two NCs
    fun nextLong(): Long {
        var neg = false
        if (c == NC) c = char
        while (c < '0' || c > '9') {
            if (c == '-') neg = true
            if(c == NC) throw Error("Bad Input")
            c = char
        }
        var res = 0L
        while (c in '0'..'9') {
            res = (res shl 3) + (res shl 1) + (c - '0')
            c = char
        }
        return if (neg) -res else res
    }
    fun nextString():String{
        val ret = StringBuilder()
        while (true){
            c = char
            if(c == NC) throw Error("Bad Input")
            if(!isWhitespace(c)){ break}
        }
        do{
            ret.append(c)
            c = char
        }while(!isWhitespace(c))
        return ret.toString()
    }
    private fun isWhitespace(c:Char):Boolean{
        return c == ' ' || c == '\n' || c == '\r' || c == '\t' || c == NC
    }
    fun rerouteInput(){
        val S = fakein.toString()
        println("New Case ")
        println(S.take(80))
        println("...")
        fakein.clear()
        IN = BufferedInputStream(S.byteInputStream(),BS)
    }
    fun flush(){
        OUT.flush()
    }
    fun takeFile(name:String){
        IN = BufferedInputStream(File(name).inputStream(),BS)
    }
}
fun keepimport(){ val st1 = TreeSet<Int>(); val st2 = TreeMap<Int,Int>()}
fun put(aa:Any){
    Reader.OUT.println(aa)
    if(interactive){ Reader.flush()}
}
fun put(vararg x:Any){
    val count = x.size
    for((pt, c) in x.withIndex()){
        Reader.OUT.print(c)
        if(pt + 1 != count) Reader.OUT.print(" ")
    }
    Reader.OUT.print("\n")
    if(interactive){ Reader.flush()}
}
fun done() = Reader.OUT.close()
fun share(aa:Any){Reader.fakein.append(format(aa) + "\n")}
val getint:Int get(){ val ans = getlong ; if(ans > Int.MAX_VALUE){IntArray(1000000000);error("Input Overflow")};return ans.toInt() }
val getlong:Long get() = Reader.nextLong()
val getstr:String get() = Reader.nextString()
fun getline(n:Int):IntArray = IntArray(n){getint}
fun getlineL(n:Int):LongArray = LongArray(n){getlong}
fun subformat(a:Any?):String{ // for not a collection
    return when(a) {
        null -> "null"
        is Iterable<*> -> a.joinToString(" ")
        is BooleanArray -> a.joinToString("") { if (it) "1" else "0" }
        is IntArray -> a.joinToString(" ")
        is LongArray -> a.joinToString(" ")
        else -> a.toString()
    } }
fun format(a:Any?):String { return when(a) {
    null -> "null"
    is BooleanArray -> a.joinToString("") { if (it) "1" else "0" }
    is Array<*> -> "\n"+a.joinToString("\n"){subformat(it)}
    else -> subformat(a)
} }
var dmark = -1
infix fun Any.dei(a:Any?){
    dmark++ ; debug()
    println("<${dmark}>   $this : ${format(a)}")
}
const val just = " "
enum class solveMode { real, rand, tc }
object solve{
    private var randCount = 100
    private var mode:solveMode = solveMode.real
    private var tcNum:Int = 0
    var rand:()->Unit = {}
    private var TC:MutableMap<Int,()->Unit> = mutableMapOf()
    private var tn:Long = 0
    fun cases(onecase:()->Unit){
        val t = if(mode == solveMode.real){if(singleCase) 1 else getint} else if(mode == solveMode.tc){1 } else randCount
        if(mode != solveMode.real) tn = System.currentTimeMillis()
        repeat(t){
            if(mode == solveMode.tc){
                TC[tcNum]?.let { it() }
                Reader.rerouteInput()
            }else if(mode == solveMode.rand){
                rand()
                Reader.rerouteInput()
            }
            onecase()
        }
        if(mode != solveMode.real){
            val dt = System.currentTimeMillis() - tn
            println("Time $dt ms ")
        }
    }
    fun rand(a:()->Unit){
        this.rand = a
    }
    fun tc(id:Int = 0,a:()->Unit){
        TC[id] = a
    }
    fun usetc(a:Int = 0 ){
        this.tcNum = a
        this.mode = solveMode.tc
    }
    fun userand(count:Int = 100){
        this.randCount = count
        this.mode = solveMode.rand
    }
}
fun debug(){}


class Graph(val n:Int, val m:Int, val directed:Boolean) {
    val maxedge = if (directed) m else m * 2
    var edgecount = 0 // directed edge counts
    val next = IntArray(maxedge)
    val head = IntArray(n) { -1 }
    val to = IntArray(maxedge)
    val from = IntArray(maxedge)
    val weights = IntArray(if (graphWeighed) m else 0) // Weights access always need shr
    private fun primitive_add(u: Int, v: Int): Int {
        next[edgecount] = head[u]
        head[u] = edgecount
        to[edgecount] = v
        from[edgecount] = u
        edgecount++
        return edgecount -1
    }
    fun add(u: Int, v: Int): Int { // return edge number, actual
        val e = primitive_add(u, v)
        if (!directed) primitive_add(v, u)
        return e
    }
    fun addWeighted(u: Int, v: Int, w: Int):Int{
        val e = add(u, v)
        weights[if(directed) e else (e shr 1)] = w
        return e
    }
    //Basic Transversals
    inline fun NS(a:Int, act:(Int)->Unit){
        var i= head[a]
        while(i != -1){
            act(to[i])
            i = next[i]
        }
    }
    inline fun NS_E(a:Int, act:(e:Int,v:Int)->Unit){
        var i= head[a]
        while(i != -1){
            act(i,to[i])
            i = next[i]
        }
    }
    inline fun everyEdge(act:(a:Int, b:Int, e:Int)->Unit){
        val s = if(directed) 1 else 2
        for(e in 0 until edgecount step s ){
            act(from[e], to[e], e)
        }
    }
    inline fun everyDirectedEdge(act:(a:Int, b:Int)->Unit){
        for(e in 0 until edgecount){
            act(from[e], to[e])
        }
    }
    //DFS order Related
    var root = 0
    var hasDFSorder:Boolean = false
    val preorder = IntArray(n)
    var postorder = IntArray(0)
    val parent = IntArray(n){-1}
    val parentEdge:IntArray = IntArray(n){-1} //if undirected, this is upto 2m
    //if v is root of component, parent[v] = v , parentEdge[v] = -1
    fun dfstree(singleComponent:Boolean){
        //if singleComponent: perform search from the root, otherwise, search from 0 through n
        hasDFSorder = true
        var preorderpt = 0
        val explored = BooleanArray(n)
        val S = IntArray(m+1)
        var pt = 0
        parent.fill(-1)
        for(i in 0 until n){
            if(parent[i] != -1 || (singleComponent && i != root)) continue
            S[pt++] = i
            parent[i] = i
            parentEdge[i] = -1
            while(pt > 0){
                val v = S[--pt]
                if(explored[v]){
                    continue
                }
                preorder[preorderpt++] = v
                explored[v] = true
                NS_E(v){e,w ->
                    if(!explored[w]){
                        S[pt++] = w
                        parent[w] = v
                        parentEdge[w] = e
                    }
                }
            }
        }
    }
    fun treeOrderDFS() = dfstree(true)
    fun dfsTreePostOrder(singleComponent:Boolean){
        //if singleComponent: perform search from the root, otherwise, search from 0 through n
        hasDFSorder = true
        var preorderpt = 0
        val explored = BooleanArray(n)
        val S = IntArray(m+1)
        val Spopped = BooleanArray(m+1)
        var pt = 0
        var postorderpt = 0
        postorder = IntArray(n)
        parent.fill(-1)
        for(i in 0 until n){
            if(parent[i] != -1 || (singleComponent && i != root)) continue
            Spopped[pt] = false
            S[pt++] = i
            parent[i] = i
            parentEdge[i] = -1
            while(pt > 0){
                val v = S[--pt]
                if(Spopped[pt]){
                    postorder[postorderpt++] = v
                }
                if(explored[v]){
                    continue
                }
                preorder[preorderpt++] = v
                Spopped[pt] = true
                explored[v] = true
                pt++
                NS_E(v){e,w ->
                    if(!explored[w]){
                        Spopped[pt] = false
                        S[pt++] = w
                        parent[w] = v
                        parentEdge[w] = e
                    }
                }
            }
        }
    }
    inline fun BFS(distRoot:Int): IntArray {
       val Q = IntArray(n)
        val explored = IntArray(n+1){-1} // also store parents
        val dist = IntArray(n){-1}
        var startpt = 0
        var endpt = -1
        //
        Q[++endpt] = distRoot
        explored[distRoot] = distRoot
        dist[distRoot] = 0
        //
        while(startpt <= endpt){
            val x = Q[startpt++]
            NS(x){ a->
                if(explored[a] == -1){
                    explored[a] = x
                    dist[a] = dist[x] + 1
                    Q[++endpt] = a
                }
            }
        }
        return dist
    }
    //Tree Transversals
    inline fun leafFirst(act:(Int)->Unit){
        if(!hasDFSorder) treeOrderDFS()
       for(i in preorder.lastIndex downTo 0){
           act(preorder[i])
       }
    }
    inline fun rootFirst(act:(Int)->Unit){
        if(!hasDFSorder) treeOrderDFS()
        for(a in preorder){
            act(a)
        }
    }
    inline fun rootFirstEdge(act:(from:Int, to:Int, e:Int)->Unit){
        if(!hasDFSorder) treeOrderDFS()
        for(i in preorder.indices) {
            val v = preorder[i]
            val p = parent[v]
            if(p == v) continue
            act(p,v,parentEdge[v])
        }
    }
    // Basic invariants maintaining
    fun calculateSizes():IntArray{
        val ret = IntArray(n){1}
        leafFirst { v -> if(parent[v] != v) ret[parent[v]] += ret[v] }
        return ret
    }
    fun calculateSubtreeSum(weights:IntArray){
        leafFirst { v -> if(parent[v] != v) weights[parent[v]] += weights[v] }
    }
    fun calculateDepth(): IntArray {
        val ret = IntArray(n)
        rootFirst { v -> if(parent[v] != v) ret[v] = ret[parent[v]] + 1  }
        return ret
    }
    inline fun subs(v:Int, act:(Int)->Unit){
        NS(v){w ->
            if(w != parent[v]) act(w)
        }
    }
    fun calculateDepthWeighted(): LongArray {
        val ret = LongArray(n)
        rootFirstEdge{from,to,e -> ret[to] = ret[from] + weights[e]}
        return ret
    }
    fun outdegree():IntArray{
        val ret = IntArray(n)
        everyDirectedEdge { a, b -> ret[a] ++  }
        return ret
    }
    fun indegree():IntArray{
        val ret = IntArray(n)
        everyDirectedEdge {a, b -> ret[b] ++}
        return ret
    }
    fun degree():IntArray = outdegree()
    fun intime():IntArray{
        val tin = IntArray(n)
        if(!hasDFSorder) treeOrderDFS()
        for(i in 0 until n) tin[preorder[i]] = i
        return tin
    }
    fun outtime():IntArray{
        val tout = intime()
        leafFirst { v ->
            val p = parent[v]
            if(p != v) tout[p] = maxOf(tout[p], tout[v])
        }
        return tout
    }
    fun rootComponent():IntArray{
        val ret = IntArray(n)
        rootFirst { v ->
            if(v == root) return@rootFirst
            if(parent[v] == root){ ret[v] = v; return@rootFirst}
            ret[v] = ret[parent[v]]
        }
        return ret
    }
    fun compress(map:IntArray): Graph {
        val max = map.maxOrNull()!!
        val G = Graph(max + 1,this.m,this.directed)
        this.everyEdge { a, b,_ ->
            if(map[a] != map[b]){
                G.add(map[a],map[b])
            }
        }
        return G
    }
}
const val graphWeighed = false


var tc = 0
fun gon(a:Any){
    tc++
    put("Case #${tc}: $a")
}

class TC(val n:Int, val m:Int, val A:IntArray, val G:Graph) {
    var ans = 0
    fun solve(){
        val heights = ints(n)


        G.leafFirst { v ->
            val p = G.parent[v]
            if(p != v){
                heights[p] = maxOf(heights[v] + 1, heights[p] )
            }
        }
        val sizes = G.calculateSizes()

        val hson = ints(n){-1}
        G.rootFirst { v ->
            var hsize = -1
            G.subs(v) { w ->
                val h = sizes[w]
                if(h > hsize) {
                    hsize = h
                    hson[v] = w
                }
            }
        }
        val bigmod = p.toLong() * p
        var ret =0
        fun dfs(v:Int):LongArray{
            val s = hson[v]
            val now:LongArray
            if(s != -1){
                now = dfs(s)
            }else{
                now = LongArray(m+1)
            }
            G.subs(v){c ->
                if(c == s) return@subs
                val g = dfs(c)
                for(i in now.indices){
                    now[i] = minOf(now[i], g[i])
                }
            }
            val a = A[v]
            for(i in m downTo 1){
                now[i] = maxOf(now[i], now[i-1] + a)
            }
            var have = 0L
            for(i in 1..m){
                have += now[i].toLong()
                if(have >= bigmod){
                    have -= bigmod
                }
//                ret = ret mp (now[i]).modded()
            }
            ret = ret mp (have).modded()
//            v dei now
            return now
        }

        dfs(0)
        ans = ret
    }
}
const val p = 998244353
const val singleCase = false
fun main(){
    Reader.takeFile("/Users/arvin/IdeaProjects/speed5/input/minflow_maxcut_input.txt")
    Reader.OUT = File("D.txt").printWriter()

    solve.tc{

        val n = 20000
        val m = n

        share("$n $m")

        val L = ints(n){rand(plarge)}

        share(L.conca)
        for(i in 2..n){
            share("${i-1} ${i}")
        }
    }
//    solve.usetc()

    val start = System.currentTimeMillis()

    val tasks = mutableListOf<TC>()
    solve.cases{


        val n = getint
        val m= getint

        val A = getline(n)
        val G = Graph(n,n-1,false)
        repeat(n-1){
            G.add(getint-1, getint-1)
        }

        val task = TC(n,m,A,G)
        tasks.add(task)
//        task.solve()
//        gon(task.ans)
    }

    val stuff = mutableListOf<Thread>()
    for(c in tasks){
        just dei "Have ${c.n} ${c.m}"
        val td = thread{
            c.solve()

            just dei "Solved ${c.n} ${c.m}"
        }
        stuff.add(td)
    }

    for(x in stuff){
        x.join()
    }


    for(x in tasks){
        gon(x.ans)
    }

    val end = System.currentTimeMillis()
    just dei "Time ${end - start} ms "
    done()
}


/*
1
4 3
4 3 2 1
1 2
2 3
3 4
5 2
 */