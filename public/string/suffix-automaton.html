
<!doctype html>
<html lang="en" class="no-js">
  <head>
    
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width,initial-scale=1">
      
      
      
      <link rel="icon" href="../favicon.ico">
      <meta name="generator" content="mkdocs-1.3.0, mkdocs-material-8.3.0">
    
    
      
        <title>Suffix Automaton - Algorithms for Competitive Programming</title>
      
    
    
      <link rel="stylesheet" href="../assets/stylesheets/main.fd896c8a.min.css">
      
        
        <link rel="stylesheet" href="../assets/stylesheets/palette.cbb835fc.min.css">
        
      
      
    
    
    
      
        
        
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
        <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:300,300i,400,400i,700,700i%7CRoboto+Mono:400,400i,700,700i&display=fallback">
        <style>:root{--md-text-font:"Roboto";--md-code-font:"Roboto Mono"}</style>
      
    
    
      <link rel="stylesheet" href="../stylesheets/extra.css">
    
    <script>__md_scope=new URL("..",location),__md_get=(e,_=localStorage,t=__md_scope)=>JSON.parse(_.getItem(t.pathname+"."+e)),__md_set=(e,_,t=localStorage,a=__md_scope)=>{try{t.setItem(a.pathname+"."+e,JSON.stringify(_))}catch(e){}}</script>
    
      
  


  
  


  <script>window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)},ga.l=+new Date,ga("create","UA-85220282-1","auto"),ga("set","anonymizeIp",!0),ga("send","pageview"),document.addEventListener("DOMContentLoaded",function(){document.forms.search&&document.forms.search.query.addEventListener("blur",function(){var e;this.value&&(e=document.location.pathname,ga("send","pageview",e+"?q="+this.value))}),"undefined"!=typeof location$&&location$.subscribe(function(e){ga("send","pageview",e.pathname)})})</script>
  <script async src="https://www.google-analytics.com/analytics.js"></script>


    
    
  </head>
  
  
    
    
      
    
    
    
    
    <body dir="ltr" data-md-color-scheme="cpalgo" data-md-color-primary="deep-purple" data-md-color-accent="">
  
    
    
      <script>var palette=__md_get("__palette");if(palette&&"object"==typeof palette.color)for(var key of Object.keys(palette.color))document.body.setAttribute("data-md-color-"+key,palette.color[key])</script>
    
    <input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer" autocomplete="off">
    <input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search" autocomplete="off">
    <label class="md-overlay" for="__drawer"></label>
    <div data-md-component="skip">
      
        
        <a href="#suffix-automaton" class="md-skip">
          Skip to content
        </a>
      
    </div>
    <div data-md-component="announce">
      
    </div>
    
    
      <!-- overwrite:
- scroll to top when clicking title
- go to main page when clicking the site title
- remove the menu button for mobile
-->


<header class="md-header" data-md-component="header">
  <script>
    function scrollToTop() {
      document.body.scrollTop = 0; // For Safari
      document.documentElement.scrollTop = 0; // For Chrome, Firefox, IE and Opera
    }
  </script>
  <nav class="md-header__inner md-grid" aria-label="Header">
    <a href="../index.html" title="Algorithms for Competitive Programming" class="md-header__button md-logo" aria-label="Algorithms for Competitive Programming" data-md-component="logo">
      
  <img src="../favicon.ico" alt="logo">

    </a>
    <div class="md-header__title" data-md-component="header-title">
      <div class="md-header__ellipsis">
        <div class="md-header__topic">
          <span class="md-ellipsis">
            <a href="../index.html" title="Algorithms for Competitive Programming" aria-label="Algorithms for Competitive Programming" data-md-component="logo">
              Algorithms for Competitive Programming
            </a>
          </span>
        </div>
        <div class="md-header__topic" data-md-component="header-topic">
          <span class="md-ellipsis">
            <a href="#" onclick="scrollToTop()">
              
                Suffix Automaton
              
            </a>
          </span>
        </div>
      </div>
    </div>
    
      <form class="md-header__option" data-md-component="palette">
        
          
          
          <input class="md-option" data-md-color-media="(prefers-color-scheme: light)" data-md-color-scheme="cpalgo" data-md-color-primary="deep-purple" data-md-color-accent=""  aria-label="Switch to dark mode"  type="radio" name="__palette" id="__palette_1">
          
            <label class="md-header__button md-icon" title="Switch to dark mode" for="__palette_2" hidden>
              <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M17 6H7c-3.31 0-6 2.69-6 6s2.69 6 6 6h10c3.31 0 6-2.69 6-6s-2.69-6-6-6zm0 10H7c-2.21 0-4-1.79-4-4s1.79-4 4-4h10c2.21 0 4 1.79 4 4s-1.79 4-4 4zM7 9c-1.66 0-3 1.34-3 3s1.34 3 3 3 3-1.34 3-3-1.34-3-3-3z"/></svg>
            </label>
          
        
          
          
          <input class="md-option" data-md-color-media="(prefers-color-scheme: dark)" data-md-color-scheme="slate" data-md-color-primary="" data-md-color-accent=""  aria-label="Switch to light mode"  type="radio" name="__palette" id="__palette_2">
          
            <label class="md-header__button md-icon" title="Switch to light mode" for="__palette_1" hidden>
              <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M17 7H7a5 5 0 0 0-5 5 5 5 0 0 0 5 5h10a5 5 0 0 0 5-5 5 5 0 0 0-5-5m0 8a3 3 0 0 1-3-3 3 3 0 0 1 3-3 3 3 0 0 1 3 3 3 3 0 0 1-3 3Z"/></svg>
            </label>
          
        
      </form>
    
    
    
      <label class="md-header__button md-icon" for="__search">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.516 6.516 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5Z"/></svg>
      </label>
      <div class="md-search" data-md-component="search" role="dialog">
  <label class="md-search__overlay" for="__search"></label>
  <div class="md-search__inner" role="search">
    <form class="md-search__form" name="search">
      <input type="text" class="md-search__input" name="query" aria-label="Search" placeholder="Search" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck="false" data-md-component="search-query" required>
      <label class="md-search__icon md-icon" for="__search">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.516 6.516 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5Z"/></svg>
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11h12Z"/></svg>
      </label>
      <nav class="md-search__options" aria-label="Search">
        
        <button type="reset" class="md-search__icon md-icon" aria-label="Clear" tabindex="-1">
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M19 6.41 17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12 19 6.41Z"/></svg>
        </button>
      </nav>
      
    </form>
    <div class="md-search__output">
      <div class="md-search__scrollwrap" data-md-scrollfix>
        <div class="md-search-result" data-md-component="search-result">
          <div class="md-search-result__meta">
            Initializing search
          </div>
          <ol class="md-search-result__list"></ol>
        </div>
      </div>
    </div>
  </div>
</div>
    
    
      <div class="md-header__source">
        <a href="https://github.com/e-maxx-eng/e-maxx-eng" title="Go to repository" class="md-source" data-md-component="source">
  <div class="md-source__icon md-icon">
    
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><!--! Font Awesome Free 6.1.1 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc.--><path d="M439.55 236.05 244 40.45a28.87 28.87 0 0 0-40.81 0l-40.66 40.63 51.52 51.52c27.06-9.14 52.68 16.77 43.39 43.68l49.66 49.66c34.23-11.8 61.18 31 35.47 56.69-26.49 26.49-70.21-2.87-56-37.34L240.22 199v121.85c25.3 12.54 22.26 41.85 9.08 55a34.34 34.34 0 0 1-48.55 0c-17.57-17.6-11.07-46.91 11.25-56v-123c-20.8-8.51-24.6-30.74-18.64-45L142.57 101 8.45 235.14a28.86 28.86 0 0 0 0 40.81l195.61 195.6a28.86 28.86 0 0 0 40.8 0l194.69-194.69a28.86 28.86 0 0 0 0-40.81z"/></svg>
  </div>
  <div class="md-source__repository">
    GitHub
  </div>
</a>
      </div>
    
  </nav>
  
</header>
    
    <div class="md-container" data-md-component="container">
      
      
        
          
        
      
      <main class="md-main" data-md-component="main">
        <div class="md-main__inner md-grid">
          
            
              
              <div class="md-sidebar md-sidebar--primary" data-md-component="sidebar" data-md-type="navigation" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    


<nav class="md-nav md-nav--primary" aria-label="Navigation" data-md-level="0">
  <label class="md-nav__title" for="__drawer">
    <a href="../index.html" title="Algorithms for Competitive Programming" class="md-nav__button md-logo" aria-label="Algorithms for Competitive Programming" data-md-component="logo">
      
  <img src="../favicon.ico" alt="logo">

    </a>
    Algorithms for Competitive Programming
  </label>
  
    <div class="md-nav__source">
      <a href="https://github.com/e-maxx-eng/e-maxx-eng" title="Go to repository" class="md-source" data-md-component="source">
  <div class="md-source__icon md-icon">
    
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><!--! Font Awesome Free 6.1.1 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc.--><path d="M439.55 236.05 244 40.45a28.87 28.87 0 0 0-40.81 0l-40.66 40.63 51.52 51.52c27.06-9.14 52.68 16.77 43.39 43.68l49.66 49.66c34.23-11.8 61.18 31 35.47 56.69-26.49 26.49-70.21-2.87-56-37.34L240.22 199v121.85c25.3 12.54 22.26 41.85 9.08 55a34.34 34.34 0 0 1-48.55 0c-17.57-17.6-11.07-46.91 11.25-56v-123c-20.8-8.51-24.6-30.74-18.64-45L142.57 101 8.45 235.14a28.86 28.86 0 0 0 0 40.81l195.61 195.6a28.86 28.86 0 0 0 40.8 0l194.69-194.69a28.86 28.86 0 0 0 0-40.81z"/></svg>
  </div>
  <div class="md-source__repository">
    GitHub
  </div>
</a>
    </div>
  
  <ul class="md-nav__list" data-md-scrollfix>
    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href="../index.html" class="md-nav__link">
        Main Page
      </a>
    </li>
  

    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href="../contrib.html" class="md-nav__link">
        How to Contribute
      </a>
    </li>
  

    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href="../preview.html" class="md-nav__link">
        Preview
      </a>
    </li>
  

    
      
      
      

  
  
  
    
    <li class="md-nav__item md-nav__item--nested">
      
      
        <input class="md-nav__toggle md-toggle" data-md-toggle="__nav_4" type="checkbox" id="__nav_4" >
      
      
      
      
        <label class="md-nav__link" for="__nav_4">
          Algebra
          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <nav class="md-nav" aria-label="Algebra" data-md-level="1">
        <label class="md-nav__title" for="__nav_4">
          <span class="md-nav__icon md-icon"></span>
          Algebra
        </label>
        <ul class="md-nav__list" data-md-scrollfix>
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../algebra/all-submasks.html" class="md-nav__link">
        Submask Enumeration
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../algebra/balanced-ternary.html" class="md-nav__link">
        Balanced Ternary
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../algebra/big-integer.html" class="md-nav__link">
        Arbitrary-Precision Arithmetic
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../algebra/binary-exp.html" class="md-nav__link">
        Binary Exponentiation
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../algebra/chinese-remainder-theorem.html" class="md-nav__link">
        Chinese Remainder Theorem
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../algebra/discrete-log.html" class="md-nav__link">
        Discrete Logarithm
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../algebra/discrete-root.html" class="md-nav__link">
        Discrete Root
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../algebra/divisors.html" class="md-nav__link">
        Number of divisors / sum of divisors
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../algebra/euclid-algorithm.html" class="md-nav__link">
        Euclidean algorithm for computing the greatest common divisor
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../algebra/extended-euclid-algorithm.html" class="md-nav__link">
        Extended Euclidean Algorithm
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../algebra/factorial-divisors.html" class="md-nav__link">
        Finding Power of Factorial Divisor
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../algebra/factorial-modulo.html" class="md-nav__link">
        Factorial modulo p
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../algebra/factorization.html" class="md-nav__link">
        Integer factorization
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../algebra/fft.html" class="md-nav__link">
        Fast Fourier transform
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../algebra/fibonacci-numbers.html" class="md-nav__link">
        Fibonacci Numbers
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../algebra/gray-code.html" class="md-nav__link">
        Gray code
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../algebra/linear-diophantine-equation.html" class="md-nav__link">
        Linear Diophantine Equation
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../algebra/linear_congruence_equation.html" class="md-nav__link">
        Linear Congruence Equation
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../algebra/module-inverse.html" class="md-nav__link">
        Modular Multiplicative Inverse
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../algebra/montgomery_multiplication.html" class="md-nav__link">
        Montgomery Multiplication
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../algebra/phi-function.html" class="md-nav__link">
        Euler's totient function
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../algebra/polynomial.html" class="md-nav__link">
        Operations on polynomials and series
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../algebra/primality_tests.html" class="md-nav__link">
        Primality tests
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../algebra/prime-sieve-linear.html" class="md-nav__link">
        Linear Sieve
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../algebra/primitive-root.html" class="md-nav__link">
        Primitive Root
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../algebra/sieve-of-eratosthenes.html" class="md-nav__link">
        Sieve of Eratosthenes
      </a>
    </li>
  

            
          
        </ul>
      </nav>
    </li>
  

    
      
      
      

  
  
  
    
    <li class="md-nav__item md-nav__item--nested">
      
      
        <input class="md-nav__toggle md-toggle" data-md-toggle="__nav_5" type="checkbox" id="__nav_5" >
      
      
      
      
        <label class="md-nav__link" for="__nav_5">
          Combinatorics
          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <nav class="md-nav" aria-label="Combinatorics" data-md-level="1">
        <label class="md-nav__title" for="__nav_5">
          <span class="md-nav__icon md-icon"></span>
          Combinatorics
        </label>
        <ul class="md-nav__list" data-md-scrollfix>
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../combinatorics/binomial-coefficients.html" class="md-nav__link">
        Binomial Coefficients
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../combinatorics/bishops-on-chessboard.html" class="md-nav__link">
        Placing Bishops on a Chessboard
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../combinatorics/bracket_sequences.html" class="md-nav__link">
        Balanced bracket sequences
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../combinatorics/burnside.html" class="md-nav__link">
        Burnside's lemma / Pólya enumeration theorem
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../combinatorics/catalan-numbers.html" class="md-nav__link">
        Catalan Numbers
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../combinatorics/counting_labeled_graphs.html" class="md-nav__link">
        Counting labeled graphs
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../combinatorics/generating_combinations.html" class="md-nav__link">
        Generating all K-combinations
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../combinatorics/inclusion-exclusion.html" class="md-nav__link">
        The Inclusion-Exclusion Principle
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../combinatorics/stars_and_bars.html" class="md-nav__link">
        Stars and bars
      </a>
    </li>
  

            
          
        </ul>
      </nav>
    </li>
  

    
      
      
      

  
  
  
    
    <li class="md-nav__item md-nav__item--nested">
      
      
        <input class="md-nav__toggle md-toggle" data-md-toggle="__nav_6" type="checkbox" id="__nav_6" >
      
      
      
      
        <label class="md-nav__link" for="__nav_6">
          Data structures
          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <nav class="md-nav" aria-label="Data structures" data-md-level="1">
        <label class="md-nav__title" for="__nav_6">
          <span class="md-nav__icon md-icon"></span>
          Data structures
        </label>
        <ul class="md-nav__list" data-md-scrollfix>
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../data_structures/deleting_in_log_n.html" class="md-nav__link">
        Deleting from a data structure in O(T(n)log n)
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../data_structures/disjoint_set_union.html" class="md-nav__link">
        Disjoint Set Union
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../data_structures/fenwick.html" class="md-nav__link">
        Fenwick Tree
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../data_structures/randomized_heap.html" class="md-nav__link">
        Randomized Heap
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../data_structures/segment_tree.html" class="md-nav__link">
        Segment Tree
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../data_structures/sparse-table.html" class="md-nav__link">
        Sparse Table
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../data_structures/sqrt-tree.html" class="md-nav__link">
        Sqrt Tree
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../data_structures/sqrt_decomposition.html" class="md-nav__link">
        Sqrt Decomposition
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../data_structures/stack_queue_modification.html" class="md-nav__link">
        Minimum stack / Minimum queue
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../data_structures/treap.html" class="md-nav__link">
        Treap (Cartesian tree)
      </a>
    </li>
  

            
          
        </ul>
      </nav>
    </li>
  

    
      
      
      

  
  
  
    
    <li class="md-nav__item md-nav__item--nested">
      
      
        <input class="md-nav__toggle md-toggle" data-md-toggle="__nav_7" type="checkbox" id="__nav_7" >
      
      
      
      
        <label class="md-nav__link" for="__nav_7">
          Dynamic programming
          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <nav class="md-nav" aria-label="Dynamic programming" data-md-level="1">
        <label class="md-nav__title" for="__nav_7">
          <span class="md-nav__icon md-icon"></span>
          Dynamic programming
        </label>
        <ul class="md-nav__list" data-md-scrollfix>
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../dynamic_programming/divide-and-conquer-dp.html" class="md-nav__link">
        Divide and Conquer DP
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../dynamic_programming/profile-dynamics.html" class="md-nav__link">
        Dynamic Programming on Broken Profile. Problem "Parquet"
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../dynamic_programming/zero_matrix.html" class="md-nav__link">
        Finding the largest zero submatrix
      </a>
    </li>
  

            
          
        </ul>
      </nav>
    </li>
  

    
      
      
      

  
  
  
    
    <li class="md-nav__item md-nav__item--nested">
      
      
        <input class="md-nav__toggle md-toggle" data-md-toggle="__nav_8" type="checkbox" id="__nav_8" >
      
      
      
      
        <label class="md-nav__link" for="__nav_8">
          Game theory
          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <nav class="md-nav" aria-label="Game theory" data-md-level="1">
        <label class="md-nav__title" for="__nav_8">
          <span class="md-nav__icon md-icon"></span>
          Game theory
        </label>
        <ul class="md-nav__list" data-md-scrollfix>
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../game_theory/games_on_graphs.html" class="md-nav__link">
        Games on arbitrary graphs
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../game_theory/sprague-grundy-nim.html" class="md-nav__link">
        Sprague-Grundy theorem. Nim
      </a>
    </li>
  

            
          
        </ul>
      </nav>
    </li>
  

    
      
      
      

  
  
  
    
    <li class="md-nav__item md-nav__item--nested">
      
      
        <input class="md-nav__toggle md-toggle" data-md-toggle="__nav_9" type="checkbox" id="__nav_9" >
      
      
      
      
        <label class="md-nav__link" for="__nav_9">
          Geometry
          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <nav class="md-nav" aria-label="Geometry" data-md-level="1">
        <label class="md-nav__title" for="__nav_9">
          <span class="md-nav__icon md-icon"></span>
          Geometry
        </label>
        <ul class="md-nav__list" data-md-scrollfix>
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../geometry/area-of-simple-polygon.html" class="md-nav__link">
        Finding area of simple polygon in O(N)
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../geometry/basic-geometry.html" class="md-nav__link">
        Basic Geometry
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../geometry/check-segments-intersection.html" class="md-nav__link">
        Check if two segments intersect
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../geometry/circle-circle-intersection.html" class="md-nav__link">
        Circle-Circle Intersection
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../geometry/circle-line-intersection.html" class="md-nav__link">
        Circle-Line Intersection
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../geometry/convex-hull.html" class="md-nav__link">
        Convex Hull construction
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../geometry/convex_hull_trick.html" class="md-nav__link">
        Convex hull trick and Li Chao tree
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../geometry/delaunay.html" class="md-nav__link">
        Delaunay triangulation and Voronoi diagram
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../geometry/halfplane-intersection.html" class="md-nav__link">
        Half-plane intersection
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../geometry/intersecting_segments.html" class="md-nav__link">
        Search for a pair of intersecting segments
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../geometry/lattice-points.html" class="md-nav__link">
        Lattice points inside non-lattice polygon
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../geometry/length-of-segments-union.html" class="md-nav__link">
        Length of the union of segments
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../geometry/lines-intersection.html" class="md-nav__link">
        Intersection Point of Lines
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../geometry/minkowski.html" class="md-nav__link">
        Minkowski sum of convex polygons
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../geometry/nearest_points.html" class="md-nav__link">
        Finding the nearest pair of points
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../geometry/oriented-triangle-area.html" class="md-nav__link">
        Oriented area of a triangle
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../geometry/picks-theorem.html" class="md-nav__link">
        Pick's Theorem
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../geometry/point-in-convex-polygon.html" class="md-nav__link">
        Check if point belongs to the convex polygon in $O(\log N)$
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../geometry/point-location.html" class="md-nav__link">
        Point location in O(log n)
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../geometry/segment-to-line.html" class="md-nav__link">
        Finding the equation of a line for a segment
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../geometry/segments-intersection.html" class="md-nav__link">
        Finding intersection of two segments
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../geometry/tangents-to-two-circles.html" class="md-nav__link">
        Finding common tangents to two circles
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../geometry/vertical_decomposition.html" class="md-nav__link">
        Vertical decomposition
      </a>
    </li>
  

            
          
        </ul>
      </nav>
    </li>
  

    
      
      
      

  
  
  
    
    <li class="md-nav__item md-nav__item--nested">
      
      
        <input class="md-nav__toggle md-toggle" data-md-toggle="__nav_10" type="checkbox" id="__nav_10" >
      
      
      
      
        <label class="md-nav__link" for="__nav_10">
          Graph
          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <nav class="md-nav" aria-label="Graph" data-md-level="1">
        <label class="md-nav__title" for="__nav_10">
          <span class="md-nav__icon md-icon"></span>
          Graph
        </label>
        <ul class="md-nav__list" data-md-scrollfix>
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../graph/01_bfs.html" class="md-nav__link">
        0-1 BFS
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../graph/2SAT.html" class="md-nav__link">
        2-SAT
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../graph/Assignment-problem-min-flow.html" class="md-nav__link">
        Solving assignment problem using min-cost-flow
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../graph/all-pair-shortest-path-floyd-warshall.html" class="md-nav__link">
        Floyd-Warshall Algorithm
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../graph/bellman_ford.html" class="md-nav__link">
        Bellman-Ford Algorithm
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../graph/bipartite-check.html" class="md-nav__link">
        Check whether a graph is bipartite
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../graph/breadth-first-search.html" class="md-nav__link">
        Breadth-first search
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../graph/bridge-searching-online.html" class="md-nav__link">
        Finding Bridges Online
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../graph/bridge-searching.html" class="md-nav__link">
        Finding bridges in a graph in O(N+M)
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../graph/cutpoints.html" class="md-nav__link">
        Finding articulation points in a graph in O(N+M)
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../graph/depth-first-search.html" class="md-nav__link">
        Depth First Search
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../graph/desopo_pape.html" class="md-nav__link">
        D´Esopo-Pape algorithm
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../graph/dijkstra.html" class="md-nav__link">
        Dijkstra Algorithm
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../graph/dijkstra_sparse.html" class="md-nav__link">
        Dijkstra on sparse graphs
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../graph/dinic.html" class="md-nav__link">
        Maximum flow - Dinic's algorithm
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../graph/edge_vertex_connectivity.html" class="md-nav__link">
        Edge connectivity / Vertex connectivity
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../graph/edmonds_karp.html" class="md-nav__link">
        Maximum flow - Ford-Fulkerson and Edmonds-Karp
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../graph/euler_path.html" class="md-nav__link">
        Finding the Eulerian path in O(M)
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../graph/finding-cycle.html" class="md-nav__link">
        Checking a graph for acyclicity and finding a cycle in O(M)
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../graph/finding-negative-cycle-in-graph.html" class="md-nav__link">
        Finding a negative cycle in the graph
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../graph/fixed_length_paths.html" class="md-nav__link">
        Number of paths of fixed length / Shortest paths of fixed length
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../graph/flow_with_demands.html" class="md-nav__link">
        Flows with demands
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../graph/hld.html" class="md-nav__link">
        Heavy-light decomposition
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../graph/kirchhoff-theorem.html" class="md-nav__link">
        Kirchhoff's theorem. Finding the number of spanning trees
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../graph/kuhn_maximum_bipartite_matching.html" class="md-nav__link">
        Kuhn's Algorithm for Maximum Bipartite Matching
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../graph/lca.html" class="md-nav__link">
        Lowest Common Ancestor - O(sqrt(N)) and O(log N) with O(N) preprocessing
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../graph/lca_binary_lifting.html" class="md-nav__link">
        Lowest Common Ancestor - Binary Lifting
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../graph/lca_farachcoltonbender.html" class="md-nav__link">
        Lowest Common Ancestor - Farach-Colton and Bender Algorithm
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../graph/lca_tarjan.html" class="md-nav__link">
        Lowest Common Ancestor - Tarjan's off-line algorithm
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../graph/min_cost_flow.html" class="md-nav__link">
        Minimum-cost flow - Successive shortest path algorithm
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../graph/mpm.html" class="md-nav__link">
        Maximum flow - MPM algorithm
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../graph/mst_kruskal.html" class="md-nav__link">
        Minimum spanning tree - Kruskal's algorithm
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../graph/mst_kruskal_with_dsu.html" class="md-nav__link">
        Minimum spanning tree - Kruskal with Disjoint Set Union
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../graph/mst_prim.html" class="md-nav__link">
        Minimum spanning tree - Prim's algorithm
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../graph/pruefer_code.html" class="md-nav__link">
        Prüfer code
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../graph/push-relabel-faster.html" class="md-nav__link">
        Maximum flow - Push-relabel method improved
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../graph/push-relabel.html" class="md-nav__link">
        Maximum flow - Push-relabel algorithm
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../graph/rmq_linear.html" class="md-nav__link">
        Solve RMQ (Range Minimum Query) by finding LCA (Lowest Common Ancestor)
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../graph/search-for-connected-components.html" class="md-nav__link">
        Search for connected components in a graph
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../graph/second_best_mst.html" class="md-nav__link">
        Second Best Minimum Spanning Tree
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../graph/strong-orientation.html" class="md-nav__link">
        Strong Orientation
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../graph/strongly-connected-components.html" class="md-nav__link">
        Finding strongly connected components / Building condensation graph
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../graph/topological-sort.html" class="md-nav__link">
        Topological Sorting
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../graph/tree_painting.html" class="md-nav__link">
        Paint the edges of the tree
      </a>
    </li>
  

            
          
        </ul>
      </nav>
    </li>
  

    
      
      
      

  
  
  
    
    <li class="md-nav__item md-nav__item--nested">
      
      
        <input class="md-nav__toggle md-toggle" data-md-toggle="__nav_11" type="checkbox" id="__nav_11" >
      
      
      
      
        <label class="md-nav__link" for="__nav_11">
          Linear algebra
          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <nav class="md-nav" aria-label="Linear algebra" data-md-level="1">
        <label class="md-nav__title" for="__nav_11">
          <span class="md-nav__icon md-icon"></span>
          Linear algebra
        </label>
        <ul class="md-nav__list" data-md-scrollfix>
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../linear_algebra/determinant-gauss.html" class="md-nav__link">
        Calculating the determinant of a matrix by Gauss
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../linear_algebra/determinant-kraut.html" class="md-nav__link">
        Calculating the determinant using Kraut method
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../linear_algebra/linear-system-gauss.html" class="md-nav__link">
        Gauss method for solving system of linear equations
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../linear_algebra/rank-matrix.html" class="md-nav__link">
        Finding the rank of a matrix
      </a>
    </li>
  

            
          
        </ul>
      </nav>
    </li>
  

    
      
      
      

  
  
  
    
    <li class="md-nav__item md-nav__item--nested">
      
      
        <input class="md-nav__toggle md-toggle" data-md-toggle="__nav_12" type="checkbox" id="__nav_12" >
      
      
      
      
        <label class="md-nav__link" for="__nav_12">
          Num methods
          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <nav class="md-nav" aria-label="Num methods" data-md-level="1">
        <label class="md-nav__title" for="__nav_12">
          <span class="md-nav__icon md-icon"></span>
          Num methods
        </label>
        <ul class="md-nav__list" data-md-scrollfix>
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../num_methods/roots_newton.html" class="md-nav__link">
        Newton's method for finding roots
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../num_methods/simpson-integration.html" class="md-nav__link">
        Integration by Simpson's formula
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../num_methods/ternary_search.html" class="md-nav__link">
        Ternary Search
      </a>
    </li>
  

            
          
        </ul>
      </nav>
    </li>
  

    
      
      
      

  
  
  
    
    <li class="md-nav__item md-nav__item--nested">
      
      
        <input class="md-nav__toggle md-toggle" data-md-toggle="__nav_13" type="checkbox" id="__nav_13" >
      
      
      
      
        <label class="md-nav__link" for="__nav_13">
          Others
          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <nav class="md-nav" aria-label="Others" data-md-level="1">
        <label class="md-nav__title" for="__nav_13">
          <span class="md-nav__icon md-icon"></span>
          Others
        </label>
        <ul class="md-nav__list" data-md-scrollfix>
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../others/15-puzzle.html" class="md-nav__link">
        15 Puzzle Game: Existence Of The Solution
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../others/josephus_problem.html" class="md-nav__link">
        Josephus Problem
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../others/maximum_average_segment.html" class="md-nav__link">
        Search the subarray with the maximum/minimum sum
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../others/stern_brocot_tree_farey_sequences.html" class="md-nav__link">
        The Stern-Brocot tree and Farey sequences
      </a>
    </li>
  

            
          
        </ul>
      </nav>
    </li>
  

    
      
      
      

  
  
  
    
    <li class="md-nav__item md-nav__item--nested">
      
      
        <input class="md-nav__toggle md-toggle" data-md-toggle="__nav_14" type="checkbox" id="__nav_14" >
      
      
      
      
        <label class="md-nav__link" for="__nav_14">
          Schedules
          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <nav class="md-nav" aria-label="Schedules" data-md-level="1">
        <label class="md-nav__title" for="__nav_14">
          <span class="md-nav__icon md-icon"></span>
          Schedules
        </label>
        <ul class="md-nav__list" data-md-scrollfix>
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../schedules/schedule-with-completion-duration.html" class="md-nav__link">
        Optimal schedule of jobs given their deadlines and durations
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../schedules/schedule_one_machine.html" class="md-nav__link">
        Scheduling jobs on one machine
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../schedules/schedule_two_machines.html" class="md-nav__link">
        Scheduling jobs on two machines
      </a>
    </li>
  

            
          
        </ul>
      </nav>
    </li>
  

    
      
      
      

  
  
  
    
    <li class="md-nav__item md-nav__item--nested">
      
      
        <input class="md-nav__toggle md-toggle" data-md-toggle="__nav_15" type="checkbox" id="__nav_15" >
      
      
      
      
        <label class="md-nav__link" for="__nav_15">
          Sequences
          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <nav class="md-nav" aria-label="Sequences" data-md-level="1">
        <label class="md-nav__title" for="__nav_15">
          <span class="md-nav__icon md-icon"></span>
          Sequences
        </label>
        <ul class="md-nav__list" data-md-scrollfix>
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../sequences/k-th.html" class="md-nav__link">
        K-th order statistic in O(N)
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../sequences/longest_increasing_subsequence.html" class="md-nav__link">
        Longest increasing subsequence
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../sequences/rmq.html" class="md-nav__link">
        Range Minimum Query
      </a>
    </li>
  

            
          
        </ul>
      </nav>
    </li>
  

    
      
      
      

  
  
    
  
  
    
    <li class="md-nav__item md-nav__item--active md-nav__item--nested">
      
      
        <input class="md-nav__toggle md-toggle" data-md-toggle="__nav_16" type="checkbox" id="__nav_16" checked>
      
      
      
      
        <label class="md-nav__link" for="__nav_16">
          String
          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <nav class="md-nav" aria-label="String" data-md-level="1">
        <label class="md-nav__title" for="__nav_16">
          <span class="md-nav__icon md-icon"></span>
          String
        </label>
        <ul class="md-nav__list" data-md-scrollfix>
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="aho_corasick.html" class="md-nav__link">
        Aho-Corasick algorithm
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="expression_parsing.html" class="md-nav__link">
        Expression parsing
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="lyndon_factorization.html" class="md-nav__link">
        Lyndon factorization
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="main_lorentz.html" class="md-nav__link">
        Finding repetitions
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="manacher.html" class="md-nav__link">
        Manacher's Algorithm - Finding all sub-palindromes in O(N)
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="prefix-function.html" class="md-nav__link">
        Prefix function. Knuth–Morris–Pratt algorithm
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="rabin-karp.html" class="md-nav__link">
        Rabin-Karp Algorithm for string matching
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="string-hashing.html" class="md-nav__link">
        String Hashing
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="suffix-array.html" class="md-nav__link">
        Suffix Array
      </a>
    </li>
  

            
          
            
              
  
  
    
  
  
    <li class="md-nav__item md-nav__item--active">
      
      <input class="md-nav__toggle md-toggle" data-md-toggle="toc" type="checkbox" id="__toc">
      
      
        
      
      
        <label class="md-nav__link md-nav__link--active" for="__toc">
          Suffix Automaton
          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <a href="suffix-automaton.html" class="md-nav__link md-nav__link--active">
        Suffix Automaton
      </a>
      
        

<nav class="md-nav md-nav--secondary" aria-label="Table of contents">
  
  
  
    
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      Table of contents
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#definition-of-a-suffix-automaton" class="md-nav__link">
    Definition of a suffix automaton
  </a>
  
    <nav class="md-nav" aria-label="Definition of a suffix automaton">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#substring-property" class="md-nav__link">
    Substring property
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#examples-of-constructed-suffix-automata" class="md-nav__link">
    Examples of constructed suffix automata
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#construction-in-linear-time" class="md-nav__link">
    Construction in linear time
  </a>
  
    <nav class="md-nav" aria-label="Construction in linear time">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#end-positions-endpos" class="md-nav__link">
    End positions
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#suffix-links-link" class="md-nav__link">
    Suffix links
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#recap" class="md-nav__link">
    Recap
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#algorithm" class="md-nav__link">
    Algorithm
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#correctness" class="md-nav__link">
    Correctness
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#linear-number-of-operations" class="md-nav__link">
    Linear number of operations
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#implementation" class="md-nav__link">
    Implementation
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#additional-properties" class="md-nav__link">
    Additional properties
  </a>
  
    <nav class="md-nav" aria-label="Additional properties">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#number-of-states" class="md-nav__link">
    Number of states
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#number-of-transitions" class="md-nav__link">
    Number of transitions
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#applications" class="md-nav__link">
    Applications
  </a>
  
    <nav class="md-nav" aria-label="Applications">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#check-for-occurrence" class="md-nav__link">
    Check for occurrence
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#number-of-different-substrings" class="md-nav__link">
    Number of different substrings
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#total-length-of-all-different-substrings" class="md-nav__link">
    Total length of all different substrings
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#lexicographically-k-th-substring" class="md-nav__link">
    Lexicographically k-th substring
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#smallest-cyclic-shift" class="md-nav__link">
    Smallest cyclic shift
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#number-of-occurrences" class="md-nav__link">
    Number of occurrences
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#first-occurrence-position" class="md-nav__link">
    First occurrence position
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#all-occurrence-positions" class="md-nav__link">
    All occurrence positions
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#shortest-non-appearing-string" class="md-nav__link">
    Shortest non-appearing string
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#longest-common-substring-of-two-strings" class="md-nav__link">
    Longest common substring of two strings
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#largest-common-substring-of-multiple-strings" class="md-nav__link">
    Largest common substring of multiple strings
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#practice-problems" class="md-nav__link">
    Practice Problems
  </a>
  
</li>
      
    </ul>
  
</nav>
      
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="suffix-tree-ukkonen.html" class="md-nav__link">
        Suffix Tree. Ukkonen's Algorithm
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="z-function.html" class="md-nav__link">
        Z-function and its calculation
      </a>
    </li>
  

            
          
        </ul>
      </nav>
    </li>
  

    
  </ul>
</nav>
                  </div>
                </div>
              </div>
            
            
              
              <div class="md-sidebar md-sidebar--secondary" data-md-component="sidebar" data-md-type="toc" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    

<nav class="md-nav md-nav--secondary" aria-label="Table of contents">
  
  
  
    
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      Table of contents
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#definition-of-a-suffix-automaton" class="md-nav__link">
    Definition of a suffix automaton
  </a>
  
    <nav class="md-nav" aria-label="Definition of a suffix automaton">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#substring-property" class="md-nav__link">
    Substring property
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#examples-of-constructed-suffix-automata" class="md-nav__link">
    Examples of constructed suffix automata
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#construction-in-linear-time" class="md-nav__link">
    Construction in linear time
  </a>
  
    <nav class="md-nav" aria-label="Construction in linear time">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#end-positions-endpos" class="md-nav__link">
    End positions
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#suffix-links-link" class="md-nav__link">
    Suffix links
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#recap" class="md-nav__link">
    Recap
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#algorithm" class="md-nav__link">
    Algorithm
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#correctness" class="md-nav__link">
    Correctness
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#linear-number-of-operations" class="md-nav__link">
    Linear number of operations
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#implementation" class="md-nav__link">
    Implementation
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#additional-properties" class="md-nav__link">
    Additional properties
  </a>
  
    <nav class="md-nav" aria-label="Additional properties">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#number-of-states" class="md-nav__link">
    Number of states
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#number-of-transitions" class="md-nav__link">
    Number of transitions
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#applications" class="md-nav__link">
    Applications
  </a>
  
    <nav class="md-nav" aria-label="Applications">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#check-for-occurrence" class="md-nav__link">
    Check for occurrence
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#number-of-different-substrings" class="md-nav__link">
    Number of different substrings
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#total-length-of-all-different-substrings" class="md-nav__link">
    Total length of all different substrings
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#lexicographically-k-th-substring" class="md-nav__link">
    Lexicographically k-th substring
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#smallest-cyclic-shift" class="md-nav__link">
    Smallest cyclic shift
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#number-of-occurrences" class="md-nav__link">
    Number of occurrences
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#first-occurrence-position" class="md-nav__link">
    First occurrence position
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#all-occurrence-positions" class="md-nav__link">
    All occurrence positions
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#shortest-non-appearing-string" class="md-nav__link">
    Shortest non-appearing string
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#longest-common-substring-of-two-strings" class="md-nav__link">
    Longest common substring of two strings
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#largest-common-substring-of-multiple-strings" class="md-nav__link">
    Largest common substring of multiple strings
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#practice-problems" class="md-nav__link">
    Practice Problems
  </a>
  
</li>
      
    </ul>
  
</nav>
                  </div>
                </div>
              </div>
            
          
          <div class="md-content" data-md-component="content">
            <article class="md-content__inner md-typeset">
              
                <script type="text/javascript">
window.onload = function() {
	const newIssueURL = "https://github.com/e-maxx-eng/e-maxx-eng/issues/new";
  const issueTitle = `Problem on article "Suffix Automaton"`;
	const issueBody = `
 **Article:** [Suffix Automaton](${window.location.href})

**Problem:**
<!--
Describe the issue of this article in detail.
-->
`;
  var issue_a = document.getElementById("report_issue_a");
  issue_a.href = `${newIssueURL}?` + `title=${encodeURIComponent(issueTitle)}&` + `body=${encodeURIComponent(issueBody)}`;
}
</script>

<a href="https://github.com/e-maxx-eng/e-maxx-eng/edit/master/src/string/suffix-automaton.md" title="Edit this page" class="md-content__button md-icon">
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20.71 7.04c.39-.39.39-1.04 0-1.41l-2.34-2.34c-.37-.39-1.02-.39-1.41 0l-1.84 1.83 3.75 3.75M3 17.25V21h3.75L17.81 9.93l-3.75-3.75L3 17.25Z"/></svg>
</a>
<a id="report_issue_a" href="" title="Report a problem" class="md-content__button md-icon">
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M13 14h-2V9h2m0 9h-2v-2h2M1 21h22L12 2 1 21Z"/></svg>
</a>
<a href="https://github.com/e-maxx-eng/e-maxx-eng/commits/master/src/string/suffix-automaton.md" title="Page authors" class="md-content__button md-icon">
  <svg xmlns="http://www.w3.org/2000/svg" enable-background="new 0 0 24 24" height="24px" viewBox="0 0 24 24" width="24px" fill="#000000"><g><rect fill="none" height="24" width="24"/></g><g><g><g><path d="M12,8.5c-0.91,0-2.75,0.46-2.75,1.38v4.62h1.5V19h2.5v-4.5h1.5V9.88C14.75,8.97,12.91,8.5,12,8.5z"/><path d="M12,2C6.47,2,2,6.47,2,12s4.47,10,10,10s10-4.48,10-10S17.52,2,12,2z M12,20c-4.42,0-8-3.58-8-8s3.58-8,8-8s8,3.58,8,8 S16.42,20,12,20z"/><circle cx="12" cy="6.5" r="1.5"/></g></g></g></svg>
</a>


<h1 id="suffix-automaton">Suffix Automaton</h1>
<p>A <strong>suffix automaton</strong> is a powerful data structure that allows solving many string-related problems. </p>
<p>For example, you can search for all occurrences of one string in another, or count the amount of different substrings of a given string.
Both tasks can be solved in linear time with the help of a suffix automaton.</p>
<p>Intuitively a suffix automaton can be understood as a compressed form of <strong>all substrings</strong> of a given string.
An impressive fact is, that the suffix automaton contains all this information in a highly compressed form.
For a string of length <span class="arithmatex">\(n\)</span> it only requires <span class="arithmatex">\(O(n)\)</span> memory.
Moreover, it can also be built in <span class="arithmatex">\(O(n)\)</span> time (if we consider the size <span class="arithmatex">\(k\)</span> of the alphabet as a constant), otherwise both the memory and the time complexity will be <span class="arithmatex">\(O(n \log k)\)</span>.</p>
<p>The linearity of the size of the suffix automaton was first discovered in 1983 by Blumer et al., and in 1985 the first linear algorithms for the construction was presented by Crochemore and Blumer.</p>
<h2 id="definition-of-a-suffix-automaton">Definition of a suffix automaton</h2>
<p>A suffix automaton for a given string <span class="arithmatex">\(s\)</span> is a minimal <strong>DFA</strong> (deterministic finite automaton / deterministic finite state machine) that accepts all the suffixes of the string <span class="arithmatex">\(s\)</span>.</p>
<p>In other words:</p>
<ul>
<li>A suffix automaton is an oriented acyclic graph.
    The vertices are called <strong>states</strong>, and the edges are called <strong>transitions</strong> between states.</li>
<li>One of the states <span class="arithmatex">\(t_0\)</span> is the <strong>initial state</strong>, and it must be the source of the graph (all other states are reachable from <span class="arithmatex">\(t_0\)</span>).</li>
<li>Each <strong>transition</strong> is labeled with some character.
    All transitions originating from a state must have <strong>different</strong> labels.</li>
<li>One or multiple states are marked as <strong>terminal states</strong>.
    If we start from the initial state <span class="arithmatex">\(t_0\)</span> and move along transitions to a terminal state, then the labels of the passed transitions must spell one of the suffixes of the string <span class="arithmatex">\(s\)</span>.
    Each of the suffixes of <span class="arithmatex">\(s\)</span> must be spellable using a path from <span class="arithmatex">\(t_0\)</span> to a terminal state.</li>
<li>The suffix automaton contains the minimum number of vertices among all automata satisfying the conditions described above.</li>
</ul>
<h3 id="substring-property">Substring property</h3>
<p>The simplest and most important property of a suffix automaton is, that it contains information about all substrings of the string <span class="arithmatex">\(s\)</span>.
Any path starting at the initial state <span class="arithmatex">\(t_0\)</span>, if we write down the labels of the transitions, forms a <strong>substring</strong> of <span class="arithmatex">\(s\)</span>.
And conversely every substring of <span class="arithmatex">\(s\)</span> corresponds to a certain path starting at <span class="arithmatex">\(t_0\)</span>.</p>
<p>In order to simplify the explanations, we will say that the substring <strong>corresponds</strong> to that path (starting at <span class="arithmatex">\(t_0\)</span> and the labels spell the substring).
And conversely we say that any path <strong>corresponds</strong> to the string spelled by its labels.</p>
<p>One or multiple paths can lead to a state.
Thus, we will say that a state <strong>corresponds</strong> to the set of strings, which correspond to these paths.</p>
<h3 id="examples-of-constructed-suffix-automata">Examples of constructed suffix automata</h3>
<p>Here we will show some examples of suffix automata for several simple strings.</p>
<p>We will denote the initial state with blue and the terminal states with green.</p>
<p>For the string <span class="arithmatex">\(s =~ \text{""}\)</span>:</p>
<p><img alt="Suffix automaton for &quot;&quot;" src="SA.png" /></p>
<p>For the string <span class="arithmatex">\(s =~ \text{"a"}\)</span>:</p>
<p><img alt="Suffix automaton for &quot;a&quot;" src="SAa.png" /></p>
<p>For the string <span class="arithmatex">\(s =~ \text{"aa"}\)</span>:</p>
<p><img alt="Suffix automaton for &quot;aa&quot;" src="SAaa.png" /></p>
<p>For the string <span class="arithmatex">\(s =~ \text{"ab"}\)</span>:</p>
<p><img alt="Suffix automaton for &quot;ab&quot;" src="SAab.png" /></p>
<p>For the string <span class="arithmatex">\(s =~ \text{"aba"}\)</span>:</p>
<p><img alt="Suffix automaton for &quot;aba&quot;" src="SAaba.png" /></p>
<p>For the string <span class="arithmatex">\(s =~ \text{"abb"}\)</span>:</p>
<p><img alt="Suffix automaton for &quot;abb&quot;" src="SAabb.png" /></p>
<p>For the string <span class="arithmatex">\(s =~ \text{"abbb"}\)</span>:</p>
<p><img alt="Suffix automaton for &quot;abbb&quot;" src="SAabbb.png" /></p>
<h2 id="construction-in-linear-time">Construction in linear time</h2>
<p>Before we describe the algorithm to construct a suffix automaton in linear time, we need to introduce several new concepts and simple proofs, which will be very important in understanding the construction.</p>
<h3 id="end-positions-endpos">End positions <span class="arithmatex">\(endpos\)</span></h3>
<p>Consider any non-empty substring <span class="arithmatex">\(t\)</span> of the string <span class="arithmatex">\(s\)</span>.
We will denote with <span class="arithmatex">\(endpos(t)\)</span> the set of all positions in the string <span class="arithmatex">\(s\)</span>, in which the occurrences of <span class="arithmatex">\(t\)</span> end. For instance, we have <span class="arithmatex">\(endpos(\text{"bc"}) = \{2, 4\}\)</span> for the string <span class="arithmatex">\(\text{"abcbc"}\)</span>.</p>
<p>We will call two substrings <span class="arithmatex">\(t_1\)</span> and <span class="arithmatex">\(t_2\)</span> <span class="arithmatex">\(endpos\)</span>-equivalent, if their ending sets coincide: <span class="arithmatex">\(endpos(t_1) = endpos(t_2)\)</span>.
Thus all non-empty substrings of the string <span class="arithmatex">\(s\)</span> can be decomposed into several <strong>equivalence classes</strong> according to their sets <span class="arithmatex">\(endpos\)</span>.</p>
<p>It turns out, that in a suffix machine <span class="arithmatex">\(endpos\)</span>-equivalent substrings <strong>correspond to the same state</strong>.
In other words the number of states in a suffix automaton is equal to the number of equivalence classes among all substrings, plus the initial state.
Each state of a suffix automaton corresponds to one or more substrings having the same value <span class="arithmatex">\(endpos\)</span>.</p>
<p>We will later describe the construction algorithm using this assumption.
We will then see, that all the required properties of a suffix automaton, except for the minimality, are fulfilled.
And the minimality follows from Nerode's theorem (which will not be proven in this article).</p>
<p>We can make some important observations concerning the values <span class="arithmatex">\(endpos\)</span>:</p>
<p><strong>Lemma 1</strong>:
Two non-empty substrings <span class="arithmatex">\(u\)</span> and <span class="arithmatex">\(w\)</span> (with <span class="arithmatex">\(length(u) \le length(w)\)</span>) are <span class="arithmatex">\(endpos\)</span>-equivalent, if and only if the string <span class="arithmatex">\(u\)</span> occurs in <span class="arithmatex">\(s\)</span> only in the form of a suffix of <span class="arithmatex">\(w\)</span>.</p>
<p>The proof is obvious.
If <span class="arithmatex">\(u\)</span> and <span class="arithmatex">\(w\)</span> have the same <span class="arithmatex">\(endpos\)</span> values, then <span class="arithmatex">\(u\)</span> is a suffix of <span class="arithmatex">\(w\)</span> and appears only in the form of a suffix of <span class="arithmatex">\(w\)</span> in <span class="arithmatex">\(s\)</span>.
And if <span class="arithmatex">\(u\)</span> is a suffix of <span class="arithmatex">\(w\)</span> and appears only in the form as a suffix in <span class="arithmatex">\(s\)</span>, then the values <span class="arithmatex">\(endpos\)</span> are equal by definition.</p>
<p><strong>Lemma 2</strong>:
Consider two non-empty substrings <span class="arithmatex">\(u\)</span> and <span class="arithmatex">\(w\)</span> (with <span class="arithmatex">\(length(u) \le length(w)\)</span>).
Then their sets <span class="arithmatex">\(endpos\)</span> either don't intersect at all, or <span class="arithmatex">\(endpos(w)\)</span> is a subset of <span class="arithmatex">\(endpos(u)\)</span>.
And it depends on if <span class="arithmatex">\(u\)</span> is a suffix of <span class="arithmatex">\(w\)</span> or not.</p>
<div class="arithmatex">\[\begin{cases}
endpos(w) \subseteq endpos(u) &amp; \text{if } u \text{ is a suffix of } w \\\\
endpos(w) \cap endpos(u) = \emptyset &amp; \text{otherwise}
\end{cases}\]</div>
<p>Proof:
If the sets <span class="arithmatex">\(endpos(u)\)</span> and <span class="arithmatex">\(endpos(w)\)</span> have at least one common element, then the strings <span class="arithmatex">\(u\)</span> and <span class="arithmatex">\(w\)</span> both end in that position, i.e. <span class="arithmatex">\(u\)</span> is a suffix of <span class="arithmatex">\(w\)</span>.
But then at every occurrence of <span class="arithmatex">\(w\)</span> also appears the substring <span class="arithmatex">\(u\)</span>, which means that <span class="arithmatex">\(endpos(w)\)</span> is a subset of <span class="arithmatex">\(endpos(u)\)</span>.</p>
<p><strong>Lemma 3</strong>:
Consider an <span class="arithmatex">\(endpos\)</span>-equivalence class.
Sort all the substrings in this class by decreasing length.
Then in the resulting sequence each substring will be one shorter than the previous one, and at the same time will be a suffix of the previous one.
In other words, in a same equivalence class, the shorter substrings are actually suffixes of the longer substrings, and they take all possible lengths in a certain interval <span class="arithmatex">\([x; y]\)</span>.</p>
<p>Proof:
Fix some <span class="arithmatex">\(endpos\)</span>-equivalence class.
If it only contains one string, then the lemma is obviously true.
Now let's say that the number of strings in the class is greater than one.</p>
<p>According to Lemma 1, two different <span class="arithmatex">\(endpos\)</span>-equivalent strings are always in such a way, that the shorter one is a proper suffix of the longer one.
Consequently, there cannot be two strings of the same length in the equivalence class.</p>
<p>Let's denote by <span class="arithmatex">\(w\)</span> the longest, and through <span class="arithmatex">\(u\)</span> the shortest string in the equivalence class.
According to Lemma 1, the string <span class="arithmatex">\(u\)</span> is a proper suffix of the string <span class="arithmatex">\(w\)</span>.
Consider now any suffix of <span class="arithmatex">\(w\)</span> with a length in the interval <span class="arithmatex">\([length(u); length(w)]\)</span>.
It is easy to see, that this suffix is also contained in the same equivalence class.
Because this suffix can only appear in the form of a suffix of <span class="arithmatex">\(w\)</span> in the string <span class="arithmatex">\(s\)</span> (since also the shorter suffix <span class="arithmatex">\(u\)</span> occurs in <span class="arithmatex">\(s\)</span> only in the form of a suffix of <span class="arithmatex">\(w\)</span>).
Consequently, according to Lemma 1, this suffix is <span class="arithmatex">\(endpos\)</span>-equivalent to the string <span class="arithmatex">\(w\)</span>.</p>
<h3 id="suffix-links-link">Suffix links <span class="arithmatex">\(link\)</span></h3>
<p>Consider some state <span class="arithmatex">\(v \ne t_0\)</span> in the automaton.
As we know, the state <span class="arithmatex">\(v\)</span> corresponds to the class of strings with the same <span class="arithmatex">\(endpos\)</span> values.
And if we denote by <span class="arithmatex">\(w\)</span> the longest of these strings, then all the other strings are suffixes of <span class="arithmatex">\(w\)</span>.</p>
<p>We also know the first few suffixes of a string <span class="arithmatex">\(w\)</span> (if we consider suffixes in descending order of their length) are all contained in this equivalence class, and all other suffixes (at least one other - the empty suffix) are in some other classes.
We denote by <span class="arithmatex">\(t\)</span> the biggest such suffix, and make a suffix link to it.</p>
<p>In other words, a <strong>suffix link</strong> <span class="arithmatex">\(link(v)\)</span> leads to the state that corresponds to the <strong>longest suffix</strong> of <span class="arithmatex">\(w\)</span> that is in another <span class="arithmatex">\(endpos\)</span>-equivalence class.</p>
<p>Here we assume that the initial state <span class="arithmatex">\(t_0\)</span> corresponds to its own equivalence class (containing only the empty string), and for convenience we set <span class="arithmatex">\(endpos(t_0) = \\{-1, 0, \dots, length(s)-1\\}\)</span>.</p>
<p><strong>Lemma 4</strong>:
Suffix links form a <strong>tree</strong> with the root <span class="arithmatex">\(t_0\)</span>.</p>
<p>Proof:
Consider an arbitrary state <span class="arithmatex">\(v \ne t_0\)</span>.
A suffix link <span class="arithmatex">\(link(v)\)</span> leads to a state corresponding to strings with strictly smaller length (this follows from the definition of the suffix links and from Lemma 3).
Therefore, by moving along the suffix links, we will sooner or later come to the initial state <span class="arithmatex">\(t_0\)</span>, which corresponds to the empty string.</p>
<p><strong>Lemma 5</strong>:
If we construct a tree using the sets <span class="arithmatex">\(endpos\)</span> (by the rule that the set of a parent node contains the sets of all children as subsets), then the structure will coincide with the tree of suffix links.</p>
<p>Proof:
The fact that we can construct a tree using the sets <span class="arithmatex">\(endpos\)</span> follows directly from Lemma 2 (that any two sets either do not intersect or one is contained in the other).</p>
<p>Let us now consider an arbitrary state <span class="arithmatex">\(v \ne t_0\)</span>, and its suffix link <span class="arithmatex">\(link(v)\)</span>.
From the definition of the suffix link and from Lemma 2 it follows that</p>
<div class="arithmatex">\[endpos(v) \subseteq endpos(link(v)),\]</div>
<p>which together with the previous lemma proves the assertion:
the tree of suffix links is essentially a tree of sets <span class="arithmatex">\(endpos\)</span>.</p>
<p>Here is an <strong>example</strong> of a tree of suffix links in the suffix automaton build for the string <span class="arithmatex">\(\text{"abcbc"}\)</span>.
The nodes are labeled with the longest substring from the corresponding equivalence class.</p>
<p><img alt="Suffix automaton for &quot;abcbc&quot; with suffix links" src="SA_suffix_links.png" /></p>
<h3 id="recap">Recap</h3>
<p>Before proceeding to the algorithm itself, we recap the accumulated knowledge, and introduce a few auxiliary notations.</p>
<ul>
<li>The substrings of the string <span class="arithmatex">\(s\)</span> can be decomposed into equivalence classes according to their end positions <span class="arithmatex">\(endpos\)</span>.</li>
<li>The suffix automaton consists of the initial state <span class="arithmatex">\(t_0\)</span>, as well as of one state for each <span class="arithmatex">\(endpos\)</span>-equivalence class.</li>
<li>For each state <span class="arithmatex">\(v\)</span> one or multiple substrings match.
  We denote by <span class="arithmatex">\(longest(v)\)</span> the longest such string, and through <span class="arithmatex">\(len(v)\)</span> its length.
  We denote by <span class="arithmatex">\(shortest(v)\)</span> the shortest such substring, and its length with <span class="arithmatex">\(minlen(v)\)</span>.
  Then all the strings corresponding to this state are different suffixes of the string <span class="arithmatex">\(longest(v)\)</span> and have all possible lengths in the interval <span class="arithmatex">\([minlength(v); len(v)]\)</span>.</li>
<li>For each state <span class="arithmatex">\(v \ne t_0\)</span> a suffix link is defined as a link, that leads to a state that corresponds to the suffix of the string <span class="arithmatex">\(longest(v)\)</span> of length <span class="arithmatex">\(minlen(v) - 1\)</span>.
  The suffix links form a tree with the root in <span class="arithmatex">\(t_0\)</span>, and at the same time this tree forms an inclusion relationship between the sets <span class="arithmatex">\(endpos\)</span>.</li>
<li>We can express <span class="arithmatex">\(minlen(v)\)</span> for <span class="arithmatex">\(v \ne t_0\)</span> using the suffix link <span class="arithmatex">\(link(v)\)</span> as:</li>
</ul>
<div class="arithmatex">\[minlen(v) = len(link(v)) + 1\]</div>
<ul>
<li>If we start from an arbitrary state <span class="arithmatex">\(v_0\)</span> and follow the suffix links, then sooner or later we will reach the initial state <span class="arithmatex">\(t_0\)</span>.
  In this case we obtain a sequence of disjoint intervals <span class="arithmatex">\([minlen(v_i); len(v_i)]\)</span>, which in union forms the continuous interval <span class="arithmatex">\([0; len(v_0)]\)</span>.</li>
</ul>
<h3 id="algorithm">Algorithm</h3>
<p>Now we can proceed to the algorithm itself.
The algorithm will be <strong>online</strong>, i.e. we will add the characters of the string one by one, and modify the automaton accordingly in each step.</p>
<p>To achieve linear memory consumption, we will only store the values <span class="arithmatex">\(len\)</span>, <span class="arithmatex">\(link\)</span> and a list of transitions in each state.
We will not label terminal states (but we will later show how to arrange these labels after constructing the suffix automaton).</p>
<p>Initially the automaton consists of a single state <span class="arithmatex">\(t_0\)</span>, which will be the index <span class="arithmatex">\(0\)</span> (the remaining states will receive the indices <span class="arithmatex">\(1, 2, \dots\)</span>).
We assign it <span class="arithmatex">\(len = 0\)</span> and <span class="arithmatex">\(link = -1\)</span> for convenience (<span class="arithmatex">\(-1\)</span> will be a fictional, non-existing state).</p>
<p>Now the whole task boils down to implementing the process of <strong>adding one character</strong> <span class="arithmatex">\(c\)</span> to the end of the current string.
Let us describe this process:</p>
<ul>
<li>Let <span class="arithmatex">\(last\)</span> be the state corresponding to the entire string before adding the character <span class="arithmatex">\(c\)</span>.
    (Initially we set <span class="arithmatex">\(last = 0\)</span>, and we will change <span class="arithmatex">\(last\)</span> in the last step of the algorithm accordingly.)</li>
<li>Create a new state <span class="arithmatex">\(cur\)</span>, and assign it with <span class="arithmatex">\(len(cur) = len(last) + 1\)</span>.
    The value <span class="arithmatex">\(link(cur)\)</span> is not known at the time.</li>
<li>Now we to the following procedure:
    We start at the state <span class="arithmatex">\(last\)</span>.
    While there isn't a transition through the letter <span class="arithmatex">\(c\)</span>, we will add a transition to the state <span class="arithmatex">\(cur\)</span>, and follow the suffix link.
    If at some point there already exists a transition through the letter <span class="arithmatex">\(c\)</span>, then we will stop and denote this state with <span class="arithmatex">\(p\)</span>.</li>
<li>If it haven't found such a state <span class="arithmatex">\(p\)</span>, then we reached the fictitious state <span class="arithmatex">\(-1\)</span>, then we can just assign <span class="arithmatex">\(link(cur) = 0\)</span> and leave.</li>
<li>Suppose now that we have found a state <span class="arithmatex">\(p\)</span>, from which there exists a transition through the letter <span class="arithmatex">\(c\)</span>.
    We will denote the state, to which the transition leads,  with <span class="arithmatex">\(q\)</span>.</li>
<li>Now we have two cases. Either <span class="arithmatex">\(len(p) + 1 = len(q)\)</span>, or not.</li>
<li>If <span class="arithmatex">\(len(p) + 1 = len(q)\)</span>, then we can simply assign <span class="arithmatex">\(link(cur) = q\)</span> and leave.</li>
<li>
<p>Otherwise it is a bit more complicated.
    It is necessary to <strong>clone</strong> the state <span class="arithmatex">\(q\)</span>:
    we create a new state <span class="arithmatex">\(clone\)</span>, copy all the data from <span class="arithmatex">\(q\)</span> (suffix link and transition) except the value <span class="arithmatex">\(len\)</span>.
    We will assign <span class="arithmatex">\(len(clone) = len(p) + 1\)</span>.</p>
<p>After cloning we direct the suffix link from <span class="arithmatex">\(cur\)</span> to <span class="arithmatex">\(clone\)</span>, and also from <span class="arithmatex">\(q\)</span> to clone.</p>
<p>Finally we need to walk from the state <span class="arithmatex">\(p\)</span> back using suffix links as long as there is a transition through <span class="arithmatex">\(c\)</span> to the state <span class="arithmatex">\(q\)</span>, and redirect all those to the state <span class="arithmatex">\(clone\)</span>.
  - In any of the three cases, after completing the procedure, we update the value <span class="arithmatex">\(last\)</span> with the state <span class="arithmatex">\(cur\)</span>.</p>
</li>
</ul>
<p>If we also want to know which states are <strong>terminal</strong> and which are not, the we can find all terminal states after constructing the complete suffix automaton for the entire string <span class="arithmatex">\(s\)</span>.
To do this, we take the state corresponding to the entire string (stored in the variable <span class="arithmatex">\(last\)</span>), and follow its suffix links until we reach the initial state.
We will mark all visited states as terminal.
It is easy to understand that by doing so we will mark exactly the states corresponding to all the suffixes of the string <span class="arithmatex">\(s\)</span>, which are exactly the terminal states.</p>
<p>In the next section we will look in detail at each step and show its <strong>correctness</strong>.</p>
<p>Here we only note that, since we only create one or two new states for each character of <span class="arithmatex">\(s\)</span>, the suffix automaton contains a <strong>linear number of states</strong>.</p>
<p>The linearity of the number of transitions, and in general the linearity of the runtime of the algorithm is less clear, and they will be proven after we proved the correctness.</p>
<h3 id="correctness">Correctness</h3>
<ul>
<li>
<p>We will call a transition <span class="arithmatex">\((p, q)\)</span> <strong>continuous</strong> if <span class="arithmatex">\(len(p) + 1 = len(q)\)</span>.
    Otherwise, i.e. when <span class="arithmatex">\(len(p) + 1 &lt; len(q)\)</span>, the transition will be called <strong>non-continuous</strong>.</p>
<p>As we can see from the description of the algorithm, continuous and non-continuous transitions will lead to different cases of the algorithm.
Continuous transitions are fixed, and will never change again.
In contrast non-continuous transition may change, when new letters are added to the string (the end of the transition edge may change).</p>
</li>
<li>
<p>To avoid ambiguity we will denote the string, for which the suffix automaton was built before adding the current character <span class="arithmatex">\(c\)</span>, with <span class="arithmatex">\(s\)</span>.</p>
</li>
<li>
<p>The algorithm begins with creating a new state <span class="arithmatex">\(cur\)</span>, which will correspond to the entire string <span class="arithmatex">\(s + c\)</span>.
    It is clear why we have to create a new state.
    Together with the new character a new equivalence class is created.</p>
</li>
<li>
<p>After creating a new state we traverse by suffix links starting from the state corresponding to the entire string <span class="arithmatex">\(s\)</span>.
    For each state we try to add a transition with the character <span class="arithmatex">\(c\)</span> to the new state <span class="arithmatex">\(cur\)</span>.
    Thus we append to each suffix of <span class="arithmatex">\(s\)</span> the character <span class="arithmatex">\(c\)</span>.
    However we can only add these new transitions, if they don't conflict with an already existing one.
    Therefore as soon as we find an already existing transition with <span class="arithmatex">\(c\)</span> we have to stop.</p>
</li>
<li>
<p>In the simplest case we reached the fictitious state <span class="arithmatex">\(-1\)</span>.
    This means we added the transition with <span class="arithmatex">\(c\)</span> to all suffixes of <span class="arithmatex">\(s\)</span>.
    This also means, that the character <span class="arithmatex">\(c\)</span> hasn't been part of the string <span class="arithmatex">\(s\)</span> before.
    Therefore the suffix link of <span class="arithmatex">\(cur\)</span> has to lead to the state <span class="arithmatex">\(0\)</span>.</p>
</li>
<li>
<p>In the second case we came across an existing transition <span class="arithmatex">\((p, q)\)</span>.
    This means that we tried to add a string <span class="arithmatex">\(x + c\)</span> (where <span class="arithmatex">\(x\)</span> is a suffix of <span class="arithmatex">\(s\)</span>) to the machine that <strong>already exists</strong> in the machine (the string <span class="arithmatex">\(x + c\)</span> already appears as a substring of <span class="arithmatex">\(s\)</span>).
    Since we assume that the automaton for the string <span class="arithmatex">\(s\)</span> is build correctly, we should not add a new transition here.</p>
<p>However there is a difficulty.
To which state should the suffix link from the state <span class="arithmatex">\(cur\)</span> lead?
We have to make a suffix link to a state, in which the longest string is exactly <span class="arithmatex">\(x + c\)</span>, i.e. the <span class="arithmatex">\(len\)</span> of this state should be <span class="arithmatex">\(len(p) + 1\)</span>.
However it is possible, that such a state doesn't yet exists, i.e. <span class="arithmatex">\(len(q) &gt; len(p) + 1\)</span>.
In this case we have to create such a state, by <strong>splitting</strong> the state <span class="arithmatex">\(q\)</span>.</p>
</li>
<li>
<p>If the transition <span class="arithmatex">\((p, q)\)</span> turns out to be continuous, then <span class="arithmatex">\(len(q) = len(p) + 1\)</span>.
    In this case everything is simple.
    We direct the suffix link from <span class="arithmatex">\(cur\)</span> to the state <span class="arithmatex">\(q\)</span>.</p>
</li>
<li>
<p>Otherwise the transition is non-continuous, i.e. <span class="arithmatex">\(len(q) &gt; len(p) + 1\)</span>.
    This means that the state <span class="arithmatex">\(q\)</span> corresponds to not only the suffix of <span class="arithmatex">\(s + c\)</span> with length <span class="arithmatex">\(len(p) + 1\)</span>, but also to longer substrings of <span class="arithmatex">\(s\)</span>.
    We can do nothing other than <strong>splitting</strong> the state <span class="arithmatex">\(q\)</span> into two sub-states, so that the first one has length <span class="arithmatex">\(len(p) + 1\)</span>.</p>
<p>How can we split a state?
We <strong>clone</strong> the state <span class="arithmatex">\(q\)</span>, which gives us the state <span class="arithmatex">\(clone\)</span>, and we set <span class="arithmatex">\(len(clone) = len(p) + 1\)</span>.
We copy all the transitions from <span class="arithmatex">\(q\)</span> to <span class="arithmatex">\(clone\)</span>, because we don't want to change the paths that traverse through <span class="arithmatex">\(q\)</span>.
Also we set the suffix link from <span class="arithmatex">\(clone\)</span> to the target of the suffix link of <span class="arithmatex">\(q\)</span>, and set the suffix link of <span class="arithmatex">\(q\)</span> to <span class="arithmatex">\(clone\)</span>.</p>
<p>And after splitting the state, we set the suffix link from <span class="arithmatex">\(cur\)</span> to <span class="arithmatex">\(clone\)</span>.</p>
<p>In the last step we change some of the transitions to <span class="arithmatex">\(q\)</span>, we redirect them to <span class="arithmatex">\(clone\)</span>.
Which transitions do we have to change?
It is enough to redirect only the transitions corresponding to all the suffixes of the string <span class="arithmatex">\(w + c\)</span> (where <span class="arithmatex">\(w\)</span> is the longest string of <span class="arithmatex">\(p\)</span>), i.e. we need to continue to move along the suffix links, starting from the vertex <span class="arithmatex">\(p\)</span> until we reach the fictitious state <span class="arithmatex">\(-1\)</span> or a transition that leads to a different state than <span class="arithmatex">\(q\)</span>.</p>
</li>
</ul>
<h3 id="linear-number-of-operations">Linear number of operations</h3>
<p>First we immediately make the assumption that the size of the alphabet is <strong>constant</strong>.
If this is not the case, then it will not be possible to talk about the linear time complexity.
The list of transitions from one vertex will be stored in a balanced tree, which allows you to quickly perform key search operations and adding keys.
Therefore if we denote with <span class="arithmatex">\(k\)</span> the size of the alphabet, then the asymptotic behavior of the algorithm will be <span class="arithmatex">\(O(n \log k)\)</span> with <span class="arithmatex">\(O(n)\)</span> memory.
However if the alphabet is small enough, then you can sacrifice memory by avoiding balanced trees, and store the transitions at each vertex as an array of length <span class="arithmatex">\(k\)</span> (for quick searching by key) and a dynamic list (to quickly traverse all available keys).
Thus we reach the <span class="arithmatex">\(O(n)\)</span> time complexity for the algorithm, but at a cost of <span class="arithmatex">\(O(n k)\)</span> memory complexity.</p>
<p>So we will consider the size of the alphabet to be constant, i.e. each operation of searching for a transition on a character, adding a transition, searching for the next transition - all these operations can be done in <span class="arithmatex">\(O(1)\)</span>.</p>
<p>If we consider all parts of the algorithm, then it contains three places in the algorithm in which the linear complexity is not obvious:</p>
<ul>
<li>The first place is the traversal through the suffix links from the state <span class="arithmatex">\(last\)</span>, adding transitions with the character <span class="arithmatex">\(c\)</span>.</li>
<li>The second place is the copying of transitions when the state <span class="arithmatex">\(q\)</span> is cloned into a new state <span class="arithmatex">\(clone\)</span>.</li>
<li>Third place is changing the transition leading to <span class="arithmatex">\(q\)</span>, redirecting them to <span class="arithmatex">\(clone\)</span>.</li>
</ul>
<p>We use the fact that the size of the suffix automaton (both in number of states and in the number of transitions) is <strong>linear</strong>.
(The proof of the linearity of the number of states is the algorithm itself, and the proof of linearity of the number of states is given below, after the implementation of the algorithm).</p>
<p>Thus the total complexity of the <strong>first and second places</strong> is obvious, after all each operation adds only one amortized new transition to the automaton.</p>
<p>It remains to estimate the total complexity of the <strong>third place</strong>, in which we redirect transitions, that pointed originally to <span class="arithmatex">\(q\)</span>, to <span class="arithmatex">\(clone\)</span>.
We denote <span class="arithmatex">\(v = longest(p)\)</span>.
This is a suffix of the string <span class="arithmatex">\(s\)</span>, and with each iteration its length decreases - and therefore the position <span class="arithmatex">\(v\)</span> as the suffix of the string <span class="arithmatex">\(s\)</span> increases monotonically with each iteration.
In this case, if before the first iteration of the loop, the corresponding string <span class="arithmatex">\(v\)</span> was at the depth <span class="arithmatex">\(k\)</span> (<span class="arithmatex">\(k \ge 2\)</span>) from <span class="arithmatex">\(last\)</span> (by counting the depth as the number of suffix links), then after the last iteration the string <span class="arithmatex">\(v + c\)</span> will be a <span class="arithmatex">\(2\)</span>-th suffix link on the path from <span class="arithmatex">\(cur\)</span> (which will become the new value <span class="arithmatex">\(last\)</span>).</p>
<p>Thus, each iteration of this loop leads to the fact that the position of the string <span class="arithmatex">\(longest(link(link(last))\)</span> as suffix of the current string will monotonically increase.
Therefore this cycle cannot be executed more than <span class="arithmatex">\(n\)</span> iterations, which was required to prove.</p>
<h3 id="implementation">Implementation</h3>
<p>First we describe a data structure that will store all information about a specific transition (<span class="arithmatex">\(len\)</span>, <span class="arithmatex">\(link\)</span> and the list of transitions).
If necessary you can add a terminal flag here, as well as other information.
We will store the list of transitions in the form of a <span class="arithmatex">\(map\)</span>, which allows us to achieve total <span class="arithmatex">\(O(n)\)</span> memory and <span class="arithmatex">\(O(n \log k)\)</span> time for processing the entire string.</p>
<div class="highlight"><pre><span></span><code><span class="k">struct</span><span class="w"> </span><span class="nc">state</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">len</span><span class="p">,</span><span class="w"> </span><span class="n">link</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">map</span><span class="o">&lt;</span><span class="kt">char</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="n">next</span><span class="p">;</span><span class="w"></span>
<span class="p">};</span><span class="w"></span>
</code></pre></div>
<p>The suffix automaton itself will be stored in an array of these structures <span class="arithmatex">\(state\)</span>.
We store the current size <span class="arithmatex">\(sz\)</span> and also the variable <span class="arithmatex">\(last\)</span>, the state corresponding to the entire string at the moment.</p>
<div class="highlight"><pre><span></span><code><span class="k">const</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">MAXLEN</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">100000</span><span class="p">;</span><span class="w"></span>
<span class="n">state</span><span class="w"> </span><span class="n">st</span><span class="p">[</span><span class="n">MAXLEN</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">2</span><span class="p">];</span><span class="w"></span>
<span class="kt">int</span><span class="w"> </span><span class="n">sz</span><span class="p">,</span><span class="w"> </span><span class="n">last</span><span class="p">;</span><span class="w"></span>
</code></pre></div>
<p>We give a function that initializes a suffix automaton (creating a suffix automaton with a single state).</p>
<div class="highlight"><pre><span></span><code><span class="kt">void</span><span class="w"> </span><span class="nf">sa_init</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">st</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">len</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">st</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">link</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">-1</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">sz</span><span class="o">++</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">last</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></div>
<p>And finally we give the implementation of the main function - which adds the next character to the end of the current line, rebuilding the machine accordingly.</p>
<div class="highlight"><pre><span></span><code><span class="kt">void</span><span class="w"> </span><span class="nf">sa_extend</span><span class="p">(</span><span class="kt">char</span><span class="w"> </span><span class="n">c</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">cur</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sz</span><span class="o">++</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">st</span><span class="p">[</span><span class="n">cur</span><span class="p">].</span><span class="n">len</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">st</span><span class="p">[</span><span class="n">last</span><span class="p">].</span><span class="n">len</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">p</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">last</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="n">p</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="mi">-1</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="o">!</span><span class="n">st</span><span class="p">[</span><span class="n">p</span><span class="p">].</span><span class="n">next</span><span class="p">.</span><span class="n">count</span><span class="p">(</span><span class="n">c</span><span class="p">))</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="n">st</span><span class="p">[</span><span class="n">p</span><span class="p">].</span><span class="n">next</span><span class="p">[</span><span class="n">c</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cur</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="n">p</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">st</span><span class="p">[</span><span class="n">p</span><span class="p">].</span><span class="n">link</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">p</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">-1</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="n">st</span><span class="p">[</span><span class="n">cur</span><span class="p">].</span><span class="n">link</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="n">q</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">st</span><span class="p">[</span><span class="n">p</span><span class="p">].</span><span class="n">next</span><span class="p">[</span><span class="n">c</span><span class="p">];</span><span class="w"></span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">st</span><span class="p">[</span><span class="n">p</span><span class="p">].</span><span class="n">len</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">st</span><span class="p">[</span><span class="n">q</span><span class="p">].</span><span class="n">len</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="n">st</span><span class="p">[</span><span class="n">cur</span><span class="p">].</span><span class="n">link</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">q</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="kt">int</span><span class="w"> </span><span class="n">clone</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sz</span><span class="o">++</span><span class="p">;</span><span class="w"></span>
<span class="w">            </span><span class="n">st</span><span class="p">[</span><span class="n">clone</span><span class="p">].</span><span class="n">len</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">st</span><span class="p">[</span><span class="n">p</span><span class="p">].</span><span class="n">len</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"></span>
<span class="w">            </span><span class="n">st</span><span class="p">[</span><span class="n">clone</span><span class="p">].</span><span class="n">next</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">st</span><span class="p">[</span><span class="n">q</span><span class="p">].</span><span class="n">next</span><span class="p">;</span><span class="w"></span>
<span class="w">            </span><span class="n">st</span><span class="p">[</span><span class="n">clone</span><span class="p">].</span><span class="n">link</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">st</span><span class="p">[</span><span class="n">q</span><span class="p">].</span><span class="n">link</span><span class="p">;</span><span class="w"></span>
<span class="w">            </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="n">p</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="mi">-1</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">st</span><span class="p">[</span><span class="n">p</span><span class="p">].</span><span class="n">next</span><span class="p">[</span><span class="n">c</span><span class="p">]</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">q</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">                </span><span class="n">st</span><span class="p">[</span><span class="n">p</span><span class="p">].</span><span class="n">next</span><span class="p">[</span><span class="n">c</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">clone</span><span class="p">;</span><span class="w"></span>
<span class="w">                </span><span class="n">p</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">st</span><span class="p">[</span><span class="n">p</span><span class="p">].</span><span class="n">link</span><span class="p">;</span><span class="w"></span>
<span class="w">            </span><span class="p">}</span><span class="w"></span>
<span class="w">            </span><span class="n">st</span><span class="p">[</span><span class="n">q</span><span class="p">].</span><span class="n">link</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">st</span><span class="p">[</span><span class="n">cur</span><span class="p">].</span><span class="n">link</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">clone</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="n">last</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cur</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></div>
<p>As mentioned above, if you sacrifice memory (<span class="arithmatex">\(O(n k)\)</span>, where <span class="arithmatex">\(k\)</span> is the size of the alphabet), then you can achieve the build time of the machine in <span class="arithmatex">\(O(n)\)</span>, even for any alphabet size <span class="arithmatex">\(k\)</span>.
But for this you will have to store an array of size <span class="arithmatex">\(k\)</span> in each state (for quickly jumping to the transition of the letter), and additional a list of all transitions (to quickly iterate over the transitions them).</p>
<h2 id="additional-properties">Additional properties</h2>
<h3 id="number-of-states">Number of states</h3>
<p>The number of states in a suffix automaton of the string <span class="arithmatex">\(s\)</span> of length <span class="arithmatex">\(n\)</span> <strong>doesn't exceed</strong> <span class="arithmatex">\(2n - 1\)</span> (for <span class="arithmatex">\(n \ge 2\)</span>).</p>
<p>The proof is the construction algorithm itself, since initially the automaton consists of one state, and in the first and second iteration only a single state will be created, and in the remaining <span class="arithmatex">\(n-2\)</span> steps at most <span class="arithmatex">\(2\)</span> states will be created each.</p>
<p>However we can also <strong>show</strong> this estimation <strong>without knowing the algorithm</strong>.
Let us recall that the number of states is equal to the number of different sets <span class="arithmatex">\(endpos\)</span>.
In addition theses sets <span class="arithmatex">\(endpos\)</span> form a tree (a parent vertex contains all children sets in his set).
Consider this tree and transform it a little bit:
as long as it has an internal vertex with only one child (which means that the set of the child misses at least one position from the parent set), we create a new child with the set of the missing positions.
In the end we have a tree in which each inner vertex has a degree greater than one, and the number of leaves does not exceed <span class="arithmatex">\(n\)</span>.
Therefore there are no more than <span class="arithmatex">\(2n - 1\)</span> vertices in such a tree.</p>
<p>This bound of the number of states can actually be achieved for each <span class="arithmatex">\(n\)</span>.
A possible string is:</p>
<div class="arithmatex">\[\text{"abbb}\dots \text{bbb"}\]</div>
<p>In each iteration, starting at the third one, the algorithm will split a state, resulting in exactly <span class="arithmatex">\(2n - 1\)</span> states.</p>
<h3 id="number-of-transitions">Number of transitions</h3>
<p>The number of transitions in a suffix automaton of a string <span class="arithmatex">\(s\)</span> of length <span class="arithmatex">\(n\)</span> <strong>doesn't exceed</strong> <span class="arithmatex">\(3n - 4\)</span> (for <span class="arithmatex">\(n \ge 3\)</span>).</p>
<p>Let us prove this:</p>
<p>Let us first estimate the number of continuous transitions.
Consider a spanning tree of the longest paths in the automaton starting in the state <span class="arithmatex">\(t_0\)</span>.
This skeleton will consist of only the continuous edges, and therefore their number is less than the number of states, i.e. it does not exceed <span class="arithmatex">\(2n - 2\)</span>.</p>
<p>Now let us estimate the number of non-continuous transitions.
Let the current non-continuous transition be <span class="arithmatex">\((p, q)\)</span> with the character <span class="arithmatex">\(c\)</span>.
We take the correspondent string <span class="arithmatex">\(u + c + w\)</span>, where the string <span class="arithmatex">\(u\)</span> corresponds to the longest path from the initial state to <span class="arithmatex">\(p\)</span>, and <span class="arithmatex">\(w\)</span> to the longest path from <span class="arithmatex">\(q\)</span> to any terminal state.
On one hand, each such string <span class="arithmatex">\(u + c + w\)</span> for each incomplete strings will be different (since the strings <span class="arithmatex">\(u\)</span> and <span class="arithmatex">\(w\)</span> are formed only by complete transitions).
On the other hand each such string <span class="arithmatex">\(u + c + w\)</span>, by the definition of the terminal states, will be a suffix of the entire string <span class="arithmatex">\(s\)</span>.
Since there are only <span class="arithmatex">\(n\)</span> non-empty suffixes of <span class="arithmatex">\(s\)</span>, and non of the strings <span class="arithmatex">\(u + c + w\)</span> can contain <span class="arithmatex">\(s\)</span> (because the entire string only contains complete transitions), the total number of incomplete transitions does not exceed <span class="arithmatex">\(n - 1\)</span>.</p>
<p>Combining these two estimates gives us the bound <span class="arithmatex">\(3n - 3\)</span>.
However, since the maximum number of states can only be achieved with the test case <span class="arithmatex">\(\text{"abbb\dots bbb"}\)</span> and this case has clearly less than <span class="arithmatex">\(3n - 3\)</span> transitions, we get the tighter bound of <span class="arithmatex">\(3n - 4\)</span> for the number of transitions in a suffix automaton.</p>
<p>This bound can also be achieved with the string:</p>
<div class="arithmatex">\[\text{"abbb}\dots \text{bbbc"}\]</div>
<h2 id="applications">Applications</h2>
<p>Here we look at some tasks that can be solved using the suffix automaton.
For the simplicity we assume that the alphabet size <span class="arithmatex">\(k\)</span> is constant, which allows us to consider the complexity of appending a character and the traversal as constant.</p>
<h3 id="check-for-occurrence">Check for occurrence</h3>
<p>Given a text <span class="arithmatex">\(T\)</span>, and multiple patters <span class="arithmatex">\(P\)</span>.
We have to check whether or not the strings <span class="arithmatex">\(P\)</span> appear as a substring of <span class="arithmatex">\(T\)</span>.</p>
<p>We build a suffix automaton of the text <span class="arithmatex">\(T\)</span> in <span class="arithmatex">\(O(length(T))\)</span> time.
To check if a pattern <span class="arithmatex">\(P\)</span> appears in <span class="arithmatex">\(T\)</span>, we follow the transitions, starting from <span class="arithmatex">\(t_0\)</span>, according to the characters of <span class="arithmatex">\(P\)</span>.
If at some point there doesn't exists a transition, then the pattern <span class="arithmatex">\(P\)</span> doesn't appear as a substring of <span class="arithmatex">\(T\)</span>.
If we can process the entire string <span class="arithmatex">\(P\)</span> this way, then the string appears in <span class="arithmatex">\(T\)</span>.</p>
<p>It is clear that this will take <span class="arithmatex">\(O(length(P))\)</span> time for each string <span class="arithmatex">\(P\)</span>.
Moreover the algorithm actually finds the length of the longest prefix of <span class="arithmatex">\(P\)</span> that appears in the text.</p>
<h3 id="number-of-different-substrings">Number of different substrings</h3>
<p>Given a string <span class="arithmatex">\(S\)</span>.
You want to compute the number of different substrings.</p>
<p>Let us build a suffix automaton for the string <span class="arithmatex">\(S\)</span>.</p>
<p>Each substring of <span class="arithmatex">\(S\)</span> corresponds to some path in the automaton.
Therefore the number of different substrings is equal to the number of different paths in the automaton starting at <span class="arithmatex">\(t_0\)</span>.</p>
<p>Given that the suffix automaton is a directed acyclic graph, the number of different ways can be computed using dynamic programming.</p>
<p>Namely, let <span class="arithmatex">\(d[v]\)</span> be the number of ways, starting at the state <span class="arithmatex">\(v\)</span> (including the path of length zero).
Then we have the recursion:</p>
<div class="arithmatex">\[d[v] = 1 + \sum_{w : (v, w, c) \in DAWG} d[w]\]</div>
<p>I.e. <span class="arithmatex">\(d[v]\)</span> can be expressed as the sum of answers for all ends of the transitions of <span class="arithmatex">\(v\)</span>.</p>
<p>The number of different substrings is the value <span class="arithmatex">\(d[t_0] - 1\)</span> (since we don't count the empty substring).</p>
<p>Total time complexity: <span class="arithmatex">\(O(length(S))\)</span></p>
<h3 id="total-length-of-all-different-substrings">Total length of all different substrings</h3>
<p>Given a string <span class="arithmatex">\(S\)</span>.
We want to compute the total length of all its various substrings.</p>
<p>The solution is similar to the previous one, only now it is necessary to consider two quantities for the dynamic programming part:
the number of different substrings <span class="arithmatex">\(d[v]\)</span> and their total length <span class="arithmatex">\(ans[v]\)</span>.</p>
<p>We already described how to compute <span class="arithmatex">\(d[v]\)</span> in the previous task.
The value <span class="arithmatex">\(ans[v]\)</span> can be computed using the recursion:</p>
<div class="arithmatex">\[ans[v] = \sum_{w : (v, w, c) \in DAWG} d[w] + ans[w]\]</div>
<p>We take the answer of each adjacent vertex <span class="arithmatex">\(w\)</span>, and add to it <span class="arithmatex">\(d[w]\)</span> (since every substrings is one character longer when starting from the state <span class="arithmatex">\(v\)</span>).</p>
<p>Again this task can be computed in <span class="arithmatex">\(O(length(S))\)</span> time.</p>
<h3 id="lexicographically-k-th-substring">Lexicographically <span class="arithmatex">\(k\)</span>-th substring</h3>
<p>Given a string <span class="arithmatex">\(S\)</span>.
We have to answer multiple queries.
For each given number <span class="arithmatex">\(K_i\)</span> we have to find the <span class="arithmatex">\(K_i\)</span>-th string in the lexicographically ordered list of all substrings.</p>
<p>The solution of this problem is based on the idea of the previous two problems.
The lexicographically <span class="arithmatex">\(k\)</span>-th substring corresponds to the lexicographically <span class="arithmatex">\(k\)</span>-th path in the suffix automaton.
Therefore after counting the number of paths from each state, we can easily search for the <span class="arithmatex">\(k\)</span>-th path starting from the root of the automaton.</p>
<p>This takes <span class="arithmatex">\(O(length(S))\)</span> time for preprocessing and then <span class="arithmatex">\(O(length(ans) \cdot k)\)</span> for each query (where <span class="arithmatex">\(ans\)</span> is the answer for the query and <span class="arithmatex">\(k\)</span> is the size of the alphabet).</p>
<h3 id="smallest-cyclic-shift">Smallest cyclic shift</h3>
<p>Given a string <span class="arithmatex">\(S\)</span>.
We want to find the lexicographically smallest cyclic shift.</p>
<p>We construct a suffix automaton for the string <span class="arithmatex">\(S + S\)</span>.
Then the automaton will contain in itself as paths all the cyclic shifts of the string <span class="arithmatex">\(S\)</span>.</p>
<p>Consequently the problem is reduced to finding the lexicographically smallest path of length <span class="arithmatex">\(length(S)\)</span>, which can be done in a trivial way: we start in the initial state and greedily pass through the transitions with the minimal character.</p>
<p>Total time complexity is <span class="arithmatex">\(O(length(S))\)</span>.</p>
<h3 id="number-of-occurrences">Number of occurrences</h3>
<p>For a given text <span class="arithmatex">\(T\)</span>.
We have to answer multiple queries.
For each given pattern <span class="arithmatex">\(P\)</span> we have to find out how many times the string <span class="arithmatex">\(P\)</span> appears in the string <span class="arithmatex">\(T\)</span> as substring.</p>
<p>We construct the suffix automaton for the text <span class="arithmatex">\(T\)</span>.</p>
<p>Next we do the following preprocessing:
for each state <span class="arithmatex">\(v\)</span> in the automaton we calculate the number <span class="arithmatex">\(cnt[v]\)</span> that is equal to the size of the set <span class="arithmatex">\(endpos(v)\)</span>.
In fact all strings corresponding to the same state <span class="arithmatex">\(v\)</span> appear in the text <span class="arithmatex">\(T\)</span> an equal amount of times, which is equal to the number of positions in the set <span class="arithmatex">\(endpos\)</span>.</p>
<p>However we cannot construct the sets <span class="arithmatex">\(endpos\)</span> explicitly, therefore we only consider their sizes <span class="arithmatex">\(cnt\)</span>.</p>
<p>To compute them we proceed as follows.
For each state, if it was not created by cloning (and if it is not the initial state <span class="arithmatex">\(t_0\)</span>), we initialize it with <span class="arithmatex">\(cnt = 1\)</span>.
Then we will go through all states in decreasing order of their length <span class="arithmatex">\(len\)</span>, and add the current value <span class="arithmatex">\(cnt[v]\)</span> to the suffix links:</p>
<div class="arithmatex">\[cnt[link(v)] \text{ += } cnt[v]\]</div>
<p>This gives the correct value for each state.</p>
<p>Why is this correct?
The total stats obtained not obtained by cloning are exactly <span class="arithmatex">\(length(T)\)</span>, and the first <span class="arithmatex">\(i\)</span> of them appeared when we added the first <span class="arithmatex">\(i\)</span> characters.
Consequently for each of these states we count the corresponding position at which it was processed.
Therefore initially we have <span class="arithmatex">\(cnt = 1\)</span> for each such state, and <span class="arithmatex">\(cnt = 0\)</span> for all other.</p>
<p>Then we apply the following operation for each <span class="arithmatex">\(v\)</span>: <span class="arithmatex">\(cnt[link(v)] \text{ += } cnt[v]\)</span>.
The meaning behind this is, that if a string <span class="arithmatex">\(v\)</span> appears <span class="arithmatex">\(cnt[v]\)</span> times, then also all its suffixes appear at the exact same end positions, therefore also <span class="arithmatex">\(cnt[v]\)</span> times.</p>
<p>Why don't we overcount in this procedure (i.e. don't count some position twice)?
Because we add the positions of a state to only one other state, so it can not happen that one state directs its positions to another state twice in two different ways.</p>
<p>Thus we can compute the quantities <span class="arithmatex">\(cnt\)</span> for all states in the automaton in <span class="arithmatex">\(O(length(T))\)</span> time.</p>
<p>After that answering a query by just looking up the value <span class="arithmatex">\(cnt[t]\)</span>, where <span class="arithmatex">\(t\)</span> is the state corresponding to the pattern, if such a state exists.
Otherwise answer with <span class="arithmatex">\(0\)</span>.
Answering a query takes <span class="arithmatex">\(O(length(P))\)</span> time.</p>
<h3 id="first-occurrence-position">First occurrence position</h3>
<p>Given a text <span class="arithmatex">\(T\)</span> and multiple queries.
For each query string <span class="arithmatex">\(P\)</span> we want to find the position of the first occurrence of <span class="arithmatex">\(P\)</span> in the string <span class="arithmatex">\(T\)</span> (the position of the beginning of <span class="arithmatex">\(P\)</span>).</p>
<p>We again construct a suffix automaton.
Additionally we precompute the position <span class="arithmatex">\(firstpos\)</span> for all states in the automaton, i.e. for each state <span class="arithmatex">\(v\)</span> we want to find the position <span class="arithmatex">\(firstpos[v]\)</span> of the end of the first occurrence.
In other words, we want to find in advance the minimal element of each set <span class="arithmatex">\(endpos\)</span> (since obviously cannot maintain all sets <span class="arithmatex">\(endpos\)</span> explicitly).</p>
<p>To maintain these positions <span class="arithmatex">\(firstpos\)</span> we extend the function <code>sa_extend()</code>.
When we create a new state <span class="arithmatex">\(cur\)</span>, we set:</p>
<div class="arithmatex">\[firstpos(cur) = len(cur) - 1\]</div>
<p>And when we clone a vertex <span class="arithmatex">\(q\)</span> as <span class="arithmatex">\(clone\)</span>, we set:</p>
<div class="arithmatex">\[firstpos(clone) = firstpos(q)\]</div>
<p>(since the only other option for a value would be <span class="arithmatex">\(firstpos(cur)\)</span> which is definitely too big)</p>
<p>Thus the answer for a query is simply <span class="arithmatex">\(firstpos(t) - length(P) + 1\)</span>, where <span class="arithmatex">\(t\)</span> is the state corresponding to the string <span class="arithmatex">\(P\)</span>.
Answering a query again takes only <span class="arithmatex">\(O(length(P))\)</span> time.</p>
<h3 id="all-occurrence-positions">All occurrence positions</h3>
<p>This time we have to display all positions of the occurrences in the string <span class="arithmatex">\(T\)</span>.</p>
<p>Again we construct a suffix automaton for the text <span class="arithmatex">\(T\)</span>.
Similar as in the previous task we compute the position <span class="arithmatex">\(firstpos\)</span> for all states.</p>
<p>Clearly <span class="arithmatex">\(firstpos(t)\)</span> is part of the answer, if <span class="arithmatex">\(t\)</span> is the state corresponding to a query string <span class="arithmatex">\(P\)</span>.
So we took into account the state of the automaton containing <span class="arithmatex">\(P\)</span>.
What other states do we need to take into account?
All states that correspond to strings for which <span class="arithmatex">\(P\)</span> is a suffix.
In other words we need to find all the states that can reach the state <span class="arithmatex">\(t\)</span> via suffix links.</p>
<p>Therefore to solve the problem we need to save for each state a list of suffix references leading to it.
The answer to the query then will then contain all <span class="arithmatex">\(firstpos\)</span> for each state that we can find on a DFS / BFS starting from the state <span class="arithmatex">\(t\)</span> using only the suffix references.</p>
<p>This workaround will work in time <span class="arithmatex">\(O(answer(P))\)</span>, because we will not visit a state twice (because only one suffix link leaves each state, so there cannot be two different paths leading to the same state).</p>
<p>We only must take into account that two different states can have the same <span class="arithmatex">\(firstpos\)</span> value.
This happens if one state was obtained by cloning another.
However, this doesn't ruin the complexity, since each state can only have at most one clone.</p>
<p>Moreover, we can also get rid of the duplicate positions, if we don't output the positions from the cloned states.
In fact a state, that a cloned state can reach, is also reachable from the original state.
Thus if we remember the flag <code>is_cloned</code> for each state, we can simply ignore the cloned states and only output <span class="arithmatex">\(firstpos\)</span> for all other states.</p>
<p>Here are some implementation sketches:</p>
<div class="highlight"><pre><span></span><code><span class="k">struct</span><span class="w"> </span><span class="nc">state</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="p">...</span><span class="w"></span>
<span class="w">    </span><span class="kt">bool</span><span class="w"> </span><span class="n">is_clone</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">first_pos</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="n">inv_link</span><span class="p">;</span><span class="w"></span>
<span class="p">};</span><span class="w"></span>

<span class="c1">// after constructing the automaton</span>
<span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">v</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"> </span><span class="n">v</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">sz</span><span class="p">;</span><span class="w"> </span><span class="n">v</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">st</span><span class="p">[</span><span class="n">st</span><span class="p">[</span><span class="n">v</span><span class="p">].</span><span class="n">link</span><span class="p">].</span><span class="n">inv_link</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">v</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="c1">// output all positions of occurrences</span>
<span class="kt">void</span><span class="w"> </span><span class="n">output_all_occurrences</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">v</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">P_length</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">st</span><span class="p">[</span><span class="n">v</span><span class="p">].</span><span class="n">is_clone</span><span class="p">)</span><span class="w"></span>
<span class="w">        </span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">st</span><span class="p">[</span><span class="n">v</span><span class="p">].</span><span class="n">first_pos</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">P_length</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">endl</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">u</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">st</span><span class="p">[</span><span class="n">v</span><span class="p">].</span><span class="n">inv_link</span><span class="p">)</span><span class="w"></span>
<span class="w">        </span><span class="n">output_all_occurrences</span><span class="p">(</span><span class="n">u</span><span class="p">,</span><span class="w"> </span><span class="n">P_length</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></div>
<h3 id="shortest-non-appearing-string">Shortest non-appearing string</h3>
<p>Given a string <span class="arithmatex">\(S\)</span> and a certain alphabet.
We have to find a string of smallest length, that doesn't appear in <span class="arithmatex">\(S\)</span>.</p>
<p>We will apply dynamic programming on the suffix automaton built for the string <span class="arithmatex">\(S\)</span>.</p>
<p>Let <span class="arithmatex">\(d[v]\)</span> be the answer for the node <span class="arithmatex">\(v\)</span>, i.e. we already processed part of the substring, are currently in the state <span class="arithmatex">\(v\)</span>, and want to find the smallest number of characters that have to be added to find a non-existent transition.
Computing <span class="arithmatex">\(d[v]\)</span> is very simple.
If there is not transition using at least one character of the alphabet, then <span class="arithmatex">\(d[v] = 1\)</span>.
Otherwise one character is not enough, and so we need to take the minimum of all answers of all transitions:</p>
<div class="arithmatex">\[d[v] = 1 + \min_{w:(v,w,c) \in SA} d[w].\]</div>
<p>The answer to the problem will be <span class="arithmatex">\(d[t_0]\)</span>, and the actual string can be restored using the computed array <span class="arithmatex">\(d[]\)</span>.</p>
<h3 id="longest-common-substring-of-two-strings">Longest common substring of two strings</h3>
<p>Given two strings <span class="arithmatex">\(S\)</span> and <span class="arithmatex">\(T\)</span>.
We have to find the longest common substring, i.e. such a string <span class="arithmatex">\(X\)</span> that appears as substring in <span class="arithmatex">\(S\)</span> and also in <span class="arithmatex">\(T\)</span>.</p>
<p>We construct a suffix automaton for the string <span class="arithmatex">\(S\)</span>.</p>
<p>We will now take the string <span class="arithmatex">\(T\)</span>, and for each prefix look for the longest suffix of this prefix in <span class="arithmatex">\(S\)</span>.
In other words, for each position in the string <span class="arithmatex">\(T\)</span>, we want to find the longest common substring of <span class="arithmatex">\(S\)</span> and <span class="arithmatex">\(T\)</span> ending in that position.</p>
<p>For this we will use two variables, the <strong>current state</strong> <span class="arithmatex">\(v\)</span>, and the <strong>current length</strong> <span class="arithmatex">\(l\)</span>.
These two variables will describe the current matching part: its length and the state that corresponds to it.</p>
<p>Initially <span class="arithmatex">\(v = t_0\)</span> and <span class="arithmatex">\(l = 0\)</span>, i.e. the match is empty.</p>
<p>Now let us describe how we can add a character <span class="arithmatex">\(T[i]\)</span> and recalculate the answer for it.</p>
<ul>
<li>If there is a transition from <span class="arithmatex">\(v\)</span> with the character <span class="arithmatex">\(T[i]\)</span>, then we simply follow the transition and increase <span class="arithmatex">\(l\)</span> by one.</li>
<li>If there is no such transition, we have to shorten the current matching part, which means that we need to follow the suffix link: <span class="arithmatex">\(v = link(v)\)</span>.
    At the same time, the current length has to be shortened.
    Obviously we need to assign <span class="arithmatex">\(l = len(v)\)</span>, since after passing through the suffix link we end up in state whose corresponding longest string is a substring.</li>
<li>If there is still no transition using the required character, we repeat and again go through the suffix link and decrease <span class="arithmatex">\(l\)</span>, until we find a transition or we reach the fictional state <span class="arithmatex">\(-1\)</span> (which means that the symbol <span class="arithmatex">\(T[i]\)</span> doesn't appear at all in <span class="arithmatex">\(S\)</span>, so we assign <span class="arithmatex">\(v = l = 0\)</span>).</li>
</ul>
<p>The answer to the task will be the maximum of all the values <span class="arithmatex">\(l\)</span>.</p>
<p>The complexity of this part is <span class="arithmatex">\(O(length(T))\)</span>, since in one move we can either increase <span class="arithmatex">\(l\)</span> by one, or make several passes through the suffix links, each one ends up reducing the value <span class="arithmatex">\(l\)</span>.</p>
<p>Implementation:</p>
<div class="highlight"><pre><span></span><code><span class="n">string</span><span class="w"> </span><span class="nf">lcs</span><span class="w"> </span><span class="p">(</span><span class="n">string</span><span class="w"> </span><span class="n">S</span><span class="p">,</span><span class="w"> </span><span class="n">string</span><span class="w"> </span><span class="n">T</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">sa_init</span><span class="p">();</span><span class="w"></span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">S</span><span class="p">.</span><span class="n">size</span><span class="p">();</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"></span>
<span class="w">        </span><span class="n">sa_extend</span><span class="p">(</span><span class="n">S</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span><span class="w"></span>

<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">v</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">l</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">best</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">bestpos</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">T</span><span class="p">.</span><span class="n">size</span><span class="p">();</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="n">v</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="o">!</span><span class="n">st</span><span class="p">[</span><span class="n">v</span><span class="p">].</span><span class="n">next</span><span class="p">.</span><span class="n">count</span><span class="p">(</span><span class="n">T</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="n">v</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">st</span><span class="p">[</span><span class="n">v</span><span class="p">].</span><span class="n">link</span><span class="w"> </span><span class="p">;</span><span class="w"></span>
<span class="w">            </span><span class="n">l</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">st</span><span class="p">[</span><span class="n">v</span><span class="p">].</span><span class="n">length</span><span class="w"> </span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">st</span><span class="p">[</span><span class="n">v</span><span class="p">].</span><span class="n">next</span><span class="p">.</span><span class="n">count</span><span class="p">(</span><span class="n">T</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="n">v</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">st</span><span class="w"> </span><span class="p">[</span><span class="n">v</span><span class="p">].</span><span class="n">next</span><span class="p">[</span><span class="n">T</span><span class="p">[</span><span class="n">i</span><span class="p">]];</span><span class="w"></span>
<span class="w">            </span><span class="n">l</span><span class="o">++</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">l</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">best</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="n">best</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">l</span><span class="p">;</span><span class="w"></span>
<span class="w">            </span><span class="n">bestpos</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">i</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">t</span><span class="p">.</span><span class="n">substr</span><span class="p">(</span><span class="n">bestpos</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">best</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">best</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"> </span>
</code></pre></div>
<h3 id="largest-common-substring-of-multiple-strings">Largest common substring of multiple strings</h3>
<p>There are <span class="arithmatex">\(k\)</span> strings <span class="arithmatex">\(S_i\)</span> given.
We have to find the longest common substring, i.e. such a string <span class="arithmatex">\(X\)</span> that appears as substring in each string <span class="arithmatex">\(S_i\)</span>.</p>
<p>We join all strings into one large string <span class="arithmatex">\(T\)</span>, separating the strings by a special characters <span class="arithmatex">\(D_i\)</span> (one for each string):</p>
<div class="arithmatex">\[T = S_1 + D_1 + S_2 + D_2 + \dots + S_k + D_k.\]</div>
<p>Then we construct the suffix automaton for the string <span class="arithmatex">\(T\)</span>.</p>
<p>Now we need to find a string in the machine, which is contained in all the strings <span class="arithmatex">\(S_i\)</span>, and this can be done by using the special added characters.
Note that if a substring is included in some string <span class="arithmatex">\(S_j\)</span>, then in the suffix automaton exists a path starting from this substring containing the character <span class="arithmatex">\(D_j\)</span> and not containing the other characters <span class="arithmatex">\(D_1, \dots, D_{j-1}, D_{j+1}, \dots, D_k\)</span>.</p>
<p>Thus we need to calculate the attainability, which tells us for each state of the machine and each symbol <span class="arithmatex">\(D_i\)</span> if there exists such a path.
This can easily be computed by DFS or BFS and dynamic programming.
After that, the answer to the problem will be the string <span class="arithmatex">\(longest(v)\)</span> for the state <span class="arithmatex">\(v\)</span>, from which the paths were exists for all special characters.</p>
<h2 id="practice-problems">Practice Problems</h2>
<ul>
<li><a href="https://atcoder.jp/contests/abc097/tasks/arc097_a">AtCoder - K-th Substring</a></li>
<li><a href="https://www.spoj.com/problems/SUBLEX/">SPOJ - SUBLEX</a></li>
<li><a href="https://codeforces.com/problemset/problem/235/C">Codeforces - Cyclical Quest</a></li>
<li><a href="https://codeforces.com/contest/128/problem/B">Codeforces - String</a></li>
</ul>

              
            </article>
            
          </div>
        </div>
        
      </main>
      

<footer class="md-footer">
  <div class="md-footer-meta md-typeset">
    <div class="md-footer-meta__inner md-grid">
      <div class="md-footer-copyright">
        
          <div class="md-footer-copyright__highlight">
            Text is available under the <a href="https://github.com/e-maxx-eng/e-maxx-eng/blob/master/LICENSE">Creative Commons Attribution Share Alike 4.0 International</a> License<br/>Copyright &copy; 2014 - 2022 by https://github.com/e-maxx-eng
          </div>
        
        
          Made with
          <a href="https://squidfunk.github.io/mkdocs-material/" target="_blank" rel="noopener">
            Material for MkDocs
          </a>
        
        
      </div>
      <div class="md-social">
  
</div>
    </div>
  </div>
</footer>

    </div>
    <div class="md-dialog" data-md-component="dialog">
      <div class="md-dialog__inner md-typeset"></div>
    </div>
    <script id="__config" type="application/json">{"base": "..", "features": [], "search": "../assets/javascripts/workers/search.b028fd86.min.js", "translations": {"clipboard.copied": "Copied to clipboard", "clipboard.copy": "Copy to clipboard", "search.config.lang": "en", "search.config.pipeline": "trimmer, stopWordFilter", "search.config.separator": "[\\s\\-]+", "search.placeholder": "Search", "search.result.more.one": "1 more on this page", "search.result.more.other": "# more on this page", "search.result.none": "No matching documents", "search.result.one": "1 matching document", "search.result.other": "# matching documents", "search.result.placeholder": "Type to start searching", "search.result.term.missing": "Missing", "select.version.title": "Select version"}}</script>
    
    
      <script src="../assets/javascripts/bundle.0f659f14.min.js"></script>
      
        <script src="../javascript/config.js"></script>
      
        <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
      
        <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/3.0.5/es5/tex-mml-chtml.js"></script>
      
    
  </body>
</html>